{
  "boilerplatevsc": {
    "prefix": "boilerplatevsc",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "template<typename T>char delim_fun(T t){string s=typeid(t).name();set<string>st={\"set\", \"vector\",\"map\"};for(auto a:st){if(s.find(a)!=std::string::npos)return'\\n';}return' ';}",
      "template<typename T,typename S,typename Q>ostream &operator<<(ostream &os,tuple<T,S,Q> &t){os<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\")\";return os;}",
      "template<typename T,typename S>ostream &operator<<(ostream &os,pair<T,S>&p){os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";return os;}",
      "template<typename T,typename S>ostream &operator<<(ostream &os,map<T,S>&v){os<<\"[ \";for(auto it=v.begin();it!=v.end();it++){os<<\"(\"<<(*it).first<<\", \"<<(*it).second <<\") \";}os <<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,vector<T>&v){char ch=delim_fun(v[0]);if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,set<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,multiset<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename...Args>void logger(string vars,Args&&...values){cerr<<vars<<\" : \";string delim;(...,(cerr<<delim<<values,delim=\", \"));cerr<<endl;}",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "#define all(x) (x).begin(), (x).end()",
      "#define precision(x) fixed << setprecision(x)",
      "#define get_set_bits(x) __builtin_popcountll(x) ",
      "#define ordered tree<big, null_type, less<big>, rb_tree_tag, tree_order_statistics_node_update>",
      "#define ordered_ms tree<pair<big, big>, null_type, less<pair<big, big>>, rb_tree_tag, tree_order_statistics_node_update>",
      "",
      "#ifdef SARVJOT ",
      "#define ds(statement) cerr << statement << endl",
      "#define dv(args...) logger(#args, args)",
      "#define sm_line  cerr << \"---------X--------\" << endl",
      "#define lg_line  cerr << \"------X----------X------\" << endl",
      "void print_pbds(ordered &v){cerr<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<endl;}",
      "void print_pbdsms(ordered_ms &v){cerr<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<endl;}",
      "#else",
      "#define ds(statement)",
      "#define dv(...)",
      "#define sm_line",
      "#define lg_line",
      "void print_pbds(ordered &v){;}",
      "void print_pbdsms(ordered_ms &v){;}",
      "#endif",
      "",
      "const big MOD = 1e9 + 7;",
      "const big INF = INT64_MAX;",
      "",
      "void solve(){",
      "    big n;",
      "    cin >> n;",
      "    vector<big> v(n);",
      "",
      "    for(big i = 0; i < n; ++i){",
      "        cin >> v[i];",
      "    }",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    cin >> test;",
      "    for (int i = 1; i <= test; ++i){",
      "        //cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "boilerplatevsc"
  },
  "boilerplate": {
    "prefix": "boilerplate",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "template<typename T>char delim_fun(T t){string s=typeid(t).name();set<string>st={\"set\", \"vector\",\"map\"};for(auto a:st){if(s.find(a)!=std::string::npos)return'\\n';}return' ';}",
      "template<typename T,typename S,typename Q>ostream &operator<<(ostream &os,tuple<T,S,Q> &t){os<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\")\";return os;}",
      "template<typename T,typename S>ostream &operator<<(ostream &os,pair<T,S>&p){os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";return os;}",
      "template<typename T,typename S>ostream &operator<<(ostream &os,map<T,S>&v){os<<\"[ \";for(auto it=v.begin();it!=v.end();it++){os<<\"(\"<<(*it).first<<\", \"<<(*it).second <<\") \";}os <<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,vector<T>&v){char ch=delim_fun(v[0]);if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,set<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename T>ostream &operator<<(ostream &os,multiset<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
      "template<typename...Args>void logger(string vars,Args&&...values){cerr<<\"\\033[31m\"<<vars<<\" : \";string delim;(...,(cerr<<delim<<values,delim=\", \"));cerr<<\"\\033[37m\"<<endl;}",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "#define all(x) (x).begin(), (x).end()",
      "#define precision(x) fixed << setprecision(x)",
      "#define get_set_bits(x) __builtin_popcountll(x) ",
      "#define ordered tree<big, null_type, less<big>, rb_tree_tag, tree_order_statistics_node_update>",
      "#define ordered_ms tree<pair<big, big>, null_type, less<pair<big, big>>, rb_tree_tag, tree_order_statistics_node_update>",
      "",
      "#ifdef SARVJOT ",
      "#define ds(statement) cerr << \"\\033[32m\" << statement << \"\\033[37m\" << endl",
      "#define dv(args...) logger(#args, args)",
      "#define sm_line  cerr << \"\\033[33m\" << \"---------X--------\" << \"\\033[37m\" << endl",
      "#define lg_line  cerr << \"\\033[34m\" << \"------X----------X------\" << \"\\033[37m\" << endl",
      "void print_pbds(ordered &v){cerr<<\"\\033[31m\"<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<\"\\033[37m\"<<endl;}",
      "void print_pbdsms(ordered_ms &v){cerr<<\"\\033[31m\"<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<\"\\033[37m\"<<endl;}",
      "#else",
      "#define ds(statement)",
      "#define dv(...)",
      "#define sm_line",
      "#define lg_line",
      "void print_pbds(ordered &v){;}",
      "void print_pbdsms(ordered_ms &v){;}",
      "#endif",
      "",
      "const big MOD = 1e9 + 7;",
      "const big INF = INT64_MAX;",
      "",
      "void solve(){",
      "    big n;",
      "    cin >> n;",
      "    vector<big> v(n);",
      "",
      "    for(big i = 0; i < n; ++i){",
      "        cin >> v[i];",
      "    }",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    cin >> test;",
      "    for (int i = 1; i <= test; ++i){",
      "        //cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "boilerplate"
  },
  "barebonesboilerplate": {
    "prefix": "barebonesboilerplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "#define all(x) (x).begin(), (x).end()",
      "",
      "void solve(){",
      "    big n;",
      "    cin >> n;",
      "    vector<big> v(n);",
      "",
      "    for(big i = 0; i < n; ++i){",
      "        cin >> v[i];",
      "    }",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    cin >> test;",
      "    for (int i = 1; i <= test; ++i){",
      "        //cout << \"Case #\" << i << \": \";",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "barebones boilerplate"
  },
  "dsaheaders": {
    "prefix": "dsaheaders",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      ""
    ],
    "description": "dsa_headers"
  },
  "segmenttree": {
    "prefix": "segmenttree",
    "body": [
      "struct segtree{",
      "    big n;",
      "    vector<big> seg_t;",
      "",
      "    segtree(vector<big> &v){",
      "        n = v.size();",
      "        seg_t = vector<big>(4 * n);",
      "        build(v, 1, 0, n - 1);",
      "    }",
      "",
      "    big combine(big a, big b){",
      "        return a + b;",
      "    }",
      "",
      "    void build(vector<big> &arr, big node, big tl, big tr){",
      "        if (tl == tr){",
      "            seg_t[node] = arr[tl];",
      "        }",
      "        else{",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            build(arr, 2 * node, tl, tm);",
      "            build(arr, 2 * node + 1, tm + 1, tr);",
      "",
      "            seg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
      "        }",
      "    }",
      "",
      "    void update(big node, big tl, big tr, big pos, big new_val){",
      "        if(!(tl <= pos && pos <= tr)){",
      "            return; ",
      "        }",
      "",
      "        if(tl == tr){",
      "            seg_t[node] = new_val;",
      "        }else{",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            update(2 * node, tl, tm, pos, new_val);",
      "            update(2 * node + 1, tm + 1, tr, pos, new_val);",
      "",
      "            seg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
      "        }",
      "    }",
      "",
      "    void update(big pos, big r, big new_val){",
      "        update(1, 0, n - 1, pos, new_val);",
      "    }",
      "",
      "    big query(big node, big tl, big tr, big l, big r){",
      "        if (l > r){",
      "            return;",
      "        }else if(l == tl && r == tr){",
      "            return seg_t[node];",
      "        }else{",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            big q1 = query(2 * node, tl, tm, l, min(r, tm));",
      "            big q2 = query(2 * node + 1, tm + 1, tr, max(l, tm + 1), r);",
      "",
      "            return combine(q1, q2);",
      "        }",
      "    }",
      "",
      "    big query(big l, big r){",
      "        return query(1, 0, n - 1, l, r);",
      "    }",
      "};"
    ],
    "description": "segment tree"
  },
  "lazysegmenttree": {
    "prefix": "lazysegmenttree",
    "body": [
      "struct segtree{",
      "    big n;",
      "    vector<big> seg_t, lazy_t;",
      "",
      "    segtree(vector<big> &v){",
      "        n = v.size();",
      "        seg_t = vector<big>(4 * n);",
      "        lazy_t = vector<big>(4 * n, 0);",
      "        build(v, 1, 0, n - 1);",
      "    }",
      "",
      "    big combine(big a, big b){",
      "        return a + b;",
      "    }",
      "",
      "    void build(vector<big> &arr, big node, big tl, big tr){",
      "        if (tl == tr){",
      "            seg_t[node] = arr[tl];",
      "        }",
      "        else{",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            build(arr, 2 * node, tl, tm);",
      "            build(arr, 2 * node + 1, tm + 1, tr);",
      "",
      "            seg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
      "        }",
      "    }",
      "",
      "    void push(big node){",
      "        big x = lazy_t[node];",
      "",
      "        seg_t[2 * node] += x;",
      "        seg_t[2 * node + 1] += x;",
      "",
      "        lazy_t[2 * node] += x;",
      "        lazy_t[2 * node + 1] += x;",
      "",
      "        lazy_t[node] = 0;",
      "    }",
      "",
      "    void update(big node, big tl, big tr, big l, big r, big new_val){",
      "        if(l > r){",
      "            return;",
      "        }else if(l == tl && tr == r){",
      "            seg_t[node] += new_val;",
      "            lazy_t[node] += new_val;",
      "        }",
      "        else{",
      "            if(lazy_t[node] != 0){",
      "                push(node);",
      "            }",
      "",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            update(2 * node, tl, tm, l, min(r, tm), new_val);",
      "            update(2 * node + 1, tm + 1, tr, max(l, tm + 1), r, new_val);",
      "",
      "            seg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
      "        }",
      "    }",
      "",
      "    void update(big l, big r, big new_val){",
      "        update(1, 0, n - 1, l, r, new_val);",
      "    }",
      "",
      "    big query(big node, big tl, big tr, big l, big r){",
      "        if (l > r){",
      "            return;",
      "        }else if(l == tl && r == tr){",
      "            return seg_t[node];",
      "        }else{",
      "            if(lazy_t[node] != 0){",
      "                push(node);",
      "            }",
      "",
      "            big tm = (tr - tl) / 2 + tl;",
      "",
      "            big q1 = query(2 * node, tl, tm, l, min(r, tm));",
      "            big q2 = query(2 * node + 1, tm + 1, tr, max(l, tm + 1), r);",
      "",
      "            return combine(q1, q2);",
      "        }",
      "    }",
      "",
      "    big query(big l, big r){",
      "        return query(1, 0, n - 1, l, r);",
      "    }",
      "};"
    ],
    "description": "lazy segment tree"
  },
  "dsudepth": {
    "prefix": "dsudepth",
    "body": [
      "struct DSU{",
      "    vector<big> par, depth;    ",
      "    big num_comps;",
      "",
      "    DSU(big n){",
      "        depth.assign(n, 1);",
      "        par.resize(n);",
      "        iota(all(depth), 0);",
      "        num_comps = n;",
      "    }",
      "",
      "    void union_(big a, big b){",
      "        a = find(a);",
      "        b = find(b);",
      "",
      "        if (a != b){",
      "            num_comps--;",
      "",
      "            if (depth[a] < depth[b]) swap(a, b);",
      "            par[b] = a;",
      "            if(depth[a] == depth[b]) ++depth[a];",
      "        }",
      "    }   ",
      "",
      "    big find(big node){",
      "        if(par[node] != node) par[node] = find(par[node]);",
      "        return par[node];",
      "    }",
      "};"
    ],
    "description": "dsu depth"
  },
  "dsusize": {
    "prefix": "dsusize",
    "body": [
      "struct DSU{",
      "    vector<big> par, size;    ",
      "    big num_comps;",
      "",
      "    DSU(big n){",
      "        size.assign(n, 1);",
      "        par.resize(n);",
      "        iota(all(par), 0);",
      "        num_comps = n;",
      "    }",
      "",
      "    void union_(big a, big b){",
      "        a = find(a);",
      "        b = find(b);",
      "",
      "        if (a != b){",
      "            num_comps--;",
      "",
      "            if (size[a] < size[b]) swap(a, b);",
      "            par[b] = a;",
      "            size[a] += size[b];",
      "        }",
      "    }   ",
      "",
      "    big find(big node){",
      "        if(par[node] != node) par[node] = find(par[node]);",
      "        return par[node];",
      "    }",
      "};"
    ],
    "description": "dsu size"
  },
  "dijkstra": {
    "prefix": "dijkstra",
    "body": [
      "// O(n*log(n) + m*log(n)) = O(m*log(n))",
      "void dijkstra(big src, big n, vector<big>& dist, vector<big>& par, vector<vector<pair<big, big>>>& g){",
      "    dist.assign(n, INF);",
      "    par.assign(n, -1);",
      "    dist[src] = 0;",
      "",
      "    priority_queue<pair<big, big>, vector<pair<big, big>>, greater<pair<big, big>>> pq;",
      "    pq.push({ 0, src });",
      "",
      "    while (!pq.empty()) {",
      "        pair<big, big> node = pq.top();",
      "        pq.pop();",
      "",
      "        big dv = node.first;",
      "        big v = node.second;",
      "",
      "        if (dv != dist[v]) {",
      "            continue;",
      "        }",
      "",
      "        for (auto nebr : g[v]) {",
      "            big to = nebr.first;",
      "            big wt = nebr.second;",
      "",
      "            big nd = dist[v] + wt;",
      "            if (nd < dist[to]) {",
      "                dist[to] = nd;",
      "                par[to] = v;",
      "                pq.push({ nd, to });",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "dijkstra"
  },
  "kruskal": {
    "prefix": "kruskal",
    "body": [
      "struct edge{",
      "    big a, b, c;",
      "",
      "    bool operator < (const edge &other){",
      "        return c < other.c;",
      "    }",
      "    ",
      "};",
      "",
      "struct kruskal{",
      "    struct DSU{",
      "        vector<big> par, size;    ",
      "        big num_comps;",
      "    ",
      "        DSU(big n){",
      "            size.assign(n, 1);",
      "            par.resize(n);",
      "            iota(all(par), 0);",
      "            num_comps = n;",
      "        }",
      "    ",
      "        void union_(big a, big b){",
      "            a = find(a);",
      "            b = find(b);",
      "    ",
      "            if (a != b){",
      "                num_comps--;",
      "    ",
      "                if (size[a] < size[b]) swap(a, b);",
      "                par[b] = a;",
      "                size[a] += size[b];",
      "            }",
      "        }   ",
      "    ",
      "        big find(big node){",
      "            if(par[node] != node) par[node] = find(par[node]);",
      "            return par[node];",
      "        }",
      "    }; ",
      "",
      "    vector<edge> g, t;",
      "    big n, cost, pos;",
      "",
      "    kruskal(big n1){",
      "        cost = 0;",
      "        pos = 1;",
      "        n = n1;",
      "    }",
      "",
      "    void init(){",
      "        assert((big)g.size() == n);",
      "",
      "        DSU dsu_s(n);",
      "        sort(all(g));",
      "",
      "        for(auto &e : g){",
      "            if(dsu_s.find(e.a) != dsu_s.find(e.b)){",
      "                dsu_s.union_(e.a, e.b);",
      "                cost += e.c;",
      "                t.push_back(e);",
      "            }",
      "        }",
      "",
      "        // check if its possible to generate a MST",
      "        big p = dsu_s.find(0);",
      "        for(big i = 1; i < n; ++i){",
      "            big cp = dsu_s.find(i); ",
      "            if(cp != p){",
      "                pos = 0;",
      "                break;",
      "            }",
      "        }",
      "    }",
      "};"
    ],
    "description": "kruskal"
  },
  "kosaraju": {
    "prefix": "kosaraju",
    "body": [
      "void dfstopo(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &topo){",
      "    vis[node] = 1;",
      "",
      "    for(auto &nebr : g[node]){",
      "        if(!vis[nebr]){",
      "            dfstopo(nebr, g, vis, topo);",
      "        }",
      "    }",
      "    topo.push_back(node);",
      "}",
      "",
      "void dfscomp(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &comp){",
      "    vis[node] = 1;",
      "    comp.push_back(node);",
      "",
      "    for(auto &nebr : g[node]){",
      "        if(!vis[nebr]){",
      "            dfscomp(nebr, g, vis, comp);",
      "        }",
      "    }",
      "}",
      "",
      "void kosaraju(vector<vector<big>> &g, vector<vector<big>> &ig, vector<big> &root, vector<big> &roots, vector<vector<big>> &cg){",
      "    big n = root.size(), r;",
      "    vector<big> vis(n), topo, comp;",
      "",
      "    for(big i = 0; i < n; ++i){",
      "        if(!vis[i]){",
      "            dfstopo(i, g, vis, topo); ",
      "        }",
      "    }",
      "",
      "    reverse(all(topo));",
      "    vis.assign(n, 0);",
      "    for(big i = 0; i < n; ++i){",
      "        if(!vis[topo[i]]){",
      "            comp.clear(); ",
      "",
      "            dfscomp(topo[i], ig, vis, comp);",
      "",
      "            r = comp.back(); ",
      "            for(auto &c : comp){",
      "                root[c] = r;",
      "            }",
      "            roots.push_back(r); ",
      "        }",
      "    }",
      "    ",
      "    for(big i = 0; i < n; ++i){",
      "        for(auto &nebr : g[i]){",
      "            if(root[i] != root[nebr]){",
      "                cg[root[i]].push_back(root[nebr]); ",
      "            }",
      "        }",
      "    }",
      "} "
    ],
    "description": "kosaraju"
  },
  "2sat": {
    "prefix": "2sat",
    "body": [
      "void dfstopo(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &topo){",
      "    vis[node] = 1;",
      " ",
      "    for(auto &nebr : g[node]){",
      "        if(!vis[nebr]){",
      "            dfstopo(nebr, g, vis, topo);",
      "        }",
      "    }",
      "    topo.push_back(node);",
      "}",
      " ",
      "void dfscomp(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &comp){",
      "    vis[node] = 1;",
      "    comp.push_back(node);",
      " ",
      "    for(auto &nebr : g[node]){",
      "        if(!vis[nebr]){",
      "            dfscomp(nebr, g, vis, comp);",
      "        }",
      "    }",
      "}",
      " ",
      "bool twosat(vector<vector<big>> &g, vector<vector<big>> &ig, vector<big> &root, vector<big> &ans){",
      "    big n = root.size(), j = 0;",
      "    vector<big> vis(n), topo, comp;",
      " ",
      "    for(big i = 0; i < n; ++i){",
      "        if(!vis[i]){",
      "            dfstopo(i, g, vis, topo); ",
      "        }",
      "    }",
      " ",
      "    reverse(all(topo));",
      "    vis.assign(n, 0);",
      "    for(big i = 0; i < n; ++i){",
      "        if(!vis[topo[i]]){",
      "            comp.clear(); ",
      " ",
      "            dfscomp(topo[i], ig, vis, comp);",
      " ",
      "            for(auto &c : comp){",
      "                root[c] = j;",
      "            }",
      "            ++j;",
      "        }",
      "    }",
      "",
      "    for(big i = 0; i < n; i += 2){",
      "        if(root[i] == root[i + 1]){",
      "            return false;",
      "        }",
      "        ans[i / 2] = root[i] > root[i + 1];",
      "    }",
      "    return true;",
      "} "
    ],
    "description": "2sat"
  },
  "kmp": {
    "prefix": "kmp",
    "body": [
      "void prefix_function(char *s, vector<big> &pi){",
      "    big m = (big)pi.size();",
      "    for (big i = 1; i < m; ++i){",
      "        big j = pi[i - 1];",
      "",
      "        while (j > 0 && s[i] != s[j]){",
      "            j = pi[j - 1];",
      "        }",
      "",
      "        if (s[i] == s[j]){",
      "            ++j;",
      "        }",
      "",
      "        pi[i] = j;",
      "    }",
      "}",
      "",
      "void kmp(char *pat, char *txt){",
      "    big m = strlen(pat);",
      "    big n = strlen(txt);",
      "",
      "    vector<big> pi(m);",
      "    prefix_function(pat, pi);",
      "",
      "    big i = 0, j = 0;",
      "",
      "    while (i < n){",
      "        if (pat[j] == txt[i]){",
      "            ++i;",
      "            ++j;",
      "        }",
      "",
      "        if (j == m){",
      "            cout << (i - j) << \" \";",
      "            j = pi[j - 1];",
      "        }",
      "        else if (i < n && pat[j] != txt[i]){",
      "            if (j != 0){",
      "                j = pi[j - 1];",
      "            }",
      "            else{",
      "                ++i;",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "kmp"
  },
  "zfunc": {
    "prefix": "zfunc",
    "body": [
      "vector<big> z_function(string &s){",
      "    big n = s.size();",
      "    // z[i] = length of largest substring starting at i which also is a prefix of s",
      "    vector<big> z(n, 0);",
      "",
      "    big l = 0, r = 0;",
      "    for(big i = 1; i < n; ++i){",
      "        if(i <= r){",
      "            z[i] = min(z[i - l], r - i + 1);",
      "        }",
      "",
      "        while(i + z[i] < n && s[i + z[i]] == s[z[i]]){",
      "            ++z[i];",
      "        }",
      "",
      "        if(i + z[i] - 1 > r){",
      "            l = i;",
      "            r = i + z[i] - 1;",
      "        }",
      "    }",
      "",
      "    return z;",
      "}"
    ],
    "description": "z_function"
  },
  "rabin": {
    "prefix": "rabin",
    "body": [
      "    int m, p; ",
      "    ",
      "    int mult(int a, int b){",
      "        return (a * 1ll * b) % m;",
      "    }",
      "    ",
      "    int add(int a, int b){",
      "        int s = a + b;",
      "        if(s > m){",
      "            s -= m;",
      "        }",
      "        return s;",
      "    }",
      "    ",
      "    int sub(int a, int b){",
      "        int d = a - b; ",
      "        if(d < 0){",
      "            d += m;",
      "        }",
      "        return d;",
      "    }",
      "    ",
      "    int power(int a, int b){",
      "        int x = 1;",
      "        while(b > 0){",
      "           if(b % 2 == 1){",
      "               x = (x * 1ll * a) % m;",
      "           } ",
      "           ",
      "           a = (a * 1ll * a) % m;",
      "           b /= 2;",
      "        }",
      "        ",
      "        return x;",
      "    }    ",
      "    ",
      "    int divi(int a, int b){",
      "        return mult(a, power(b, m - 2));",
      "    }",
      "    ",
      "    void precompute_hash(string &str, vector<int> &hash){",
      "        int n = str.size();",
      "        hash.assign(n, 0);",
      "        ",
      "        for(int i = 0; i < n; i++){",
      "            hash[i] = mult(power(p, i), str[i] - 'a' + 1);",
      "            if(i != 0)",
      "                hash[i] = add(hash[i - 1], hash[i]);",
      "        }",
      "    }",
      "    ",
      "    int give_hash(int l, int r, vector<int> &hash){",
      "        if(l == 0){",
      "            return hash[r];",
      "        } else{",
      "            return divi(sub(hash[r], hash[l - 1]), power(p, l));",
      "        }",
      "    }",
      "    ",
      "    int give_hash(string &str){",
      "        int n = str.size();",
      "        int x = 0;",
      "        ",
      "        for(int i = 0; i < n; i++){",
      "            x = add(x, mult(power(p, i), str[i] - 'a' + 1));",
      "        }",
      "        ",
      "        return x;",
      "    }",
      "    ",
      "    int rabin_karp(string haystack, string needle) {",
      "        m = 1e9 + 7;",
      "        p = 33;",
      "        ",
      "        int nl = needle.size();",
      "        int nh = haystack.size();",
      "        ",
      "        if(nl == 0) return 0;",
      "        ",
      "        vector<int> hash;",
      "        ",
      "        int needle_hash = give_hash(needle);",
      "        precompute_hash(haystack, hash);",
      "        ",
      "        for(int i = 0; i < nh - nl + 1; i++){",
      "            if(needle_hash == give_hash(i, i + nl - 1, hash)){",
      "                return i;",
      "            }",
      "        }",
      "        ",
      "        return -1;",
      "    }"
    ],
    "description": "rabin karp"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "big lim = 1e6;",
      "vector<bool> sieve(lim + 1, true);",
      "vector<big> sieveCount(lim + 1, 0);",
      "vector<big> primeNumbers;",
      "vector<big> spf(lim + 1, 1);",
      "",
      "void precomputeSieve(){",
      "    sieve[0] = false;",
      "    sieve[1] = false;",
      "    big sn = sqrt(lim);",
      "",
      "    // initialising spf - O(n)",
      "    for (big i = 1; i <= lim; ++i){",
      "        spf[i] = i;",
      "    }",
      "",
      "    // primary sieve and calculating Smallest Prime Factor - O(nloglogn)",
      "    for (big i = 2; i <= sn; ++i){",
      "        if (sieve[i]){",
      "            for (big j = i * i; j <= lim; j += i){",
      "                if (spf[j] == j){",
      "                    spf[j] = i;",
      "                }",
      "                sieve[j] = false;",
      "            }",
      "        }",
      "    }",
      "",
      "    // storing prime numbers - O(N)",
      "    big ctr = 0;",
      "    for (big i = 0; i < lim; ++i){",
      "        if (sieve[i]){",
      "            ++ctr;",
      "            primeNumbers.push_back(i);",
      "        }",
      "        sieveCount[i] = ctr;",
      "    }",
      "}"
    ],
    "description": "sieve"
  },
  "trie": {
    "prefix": "trie",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define ds(statement) cerr << statement << endl",
      "#define dv(var) cerr << (#var) << \": \" << var << endl",
      "#else",
      "#define ds(statement)",
      "#define dv(var)",
      "#endif",
      "",
      "const big MOD = 1e9 + 7;",
      "const big INF = INT64_MAX;",
      "",
      "struct trie{",
      "    vector<trie *> children;",
      "",
      "    trie(){",
      "        children = vector<trie *>(26, NULL);",
      "    }",
      "};",
      "",
      "trie *root;",
      "",
      "void insert(string &str){",
      "    trie *cur = root;",
      "",
      "    for (char ch : str){",
      "        big ind = ch - 'a';",
      "",
      "        if (cur->children[ind] == NULL){",
      "            cur->children[ind] = new trie;",
      "        }",
      "",
      "        cur = cur->children[ind];",
      "    }",
      "}",
      "",
      "void generate_trie(string &str){",
      "    big n = str.size();",
      "    for (big i = 0; i < n; ++i){",
      "        string t = str.substr(i);",
      "        insert(t);",
      "    }",
      "}",
      "",
      "big dfs_trie(string &s, trie *cur, big k){",
      "    big ans = 0;",
      "",
      "    if (cur != root){",
      "        ans = 1;",
      "    }",
      "",
      "    for (big i = 0; i < 26; ++i){",
      "        if (cur->children[i] != NULL){",
      "            if (s[i] == '0'){",
      "                if (k > 0){",
      "                    ans += dfs_trie(s, cur->children[i], k - 1);",
      "                }",
      "            }",
      "            else{",
      "                ans += dfs_trie(s, cur->children[i], k);",
      "            }",
      "        }",
      "    }",
      "",
      "    return ans;",
      "}",
      "",
      "void solve(){",
      "    root = new trie();",
      "",
      "    string s1, s2;",
      "    big k;",
      "    cin >> s1 >> s2 >> k;",
      "",
      "    generate_trie(s1);",
      "    big ans = dfs_trie(s2, root, k);",
      "",
      "    cout << ans << nl;",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    // cin >> test;",
      "    while (test-- > 0){",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "trie beta"
  },
  "matrixexpo": {
    "prefix": "matrixexpo",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define ds(statement) cerr << statement << endl",
      "#define dv(var) cerr << (#var) << \": \" << var << endl",
      "#else",
      "#define ds(statement)",
      "#define dv(var)",
      "#endif",
      "",
      "const big MOD = 1e9 + 7;",
      "const big INF = INT64_MAX;",
      "",
      "big add(big a, big b){",
      "\tbig ans = a + b;",
      "\tif(ans >= MOD) ans -= MOD;",
      "\treturn ans;",
      "}",
      "",
      "big mult(big a, big b){",
      "    return (a * 1LL * b) % MOD;",
      "}",
      "",
      "struct Matrix{",
      "    big a[2][2] = {{0, 0}, {0, 0}};",
      "    Matrix operator*(const Matrix &other){",
      "        Matrix prod;",
      "        for (big i = 0; i < 2; ++i){",
      "            for (big j = 0; j < 2; ++j){",
      "                for (big k = 0; k < 2; ++k){",
      "                    prod.a[i][j] = add(prod.a[i][j], mult(a[i][k], other.a[k][j]));",
      "                }",
      "            }",
      "        }",
      "        return prod;",
      "    }",
      "};",
      "",
      "Matrix power(Matrix a, big k){",
      "    Matrix prod;",
      "",
      "    for (int i = 0; i < 2; ++i){",
      "        prod.a[i][i] = 1;",
      "    }",
      "",
      "    while (k > 0){",
      "        if (k % 2 == 1){",
      "            prod = prod * a;",
      "        }",
      "        a = a * a;",
      "        k /= 2;",
      "    }",
      "",
      "    return prod;",
      "}",
      "",
      "void solve(){",
      "    big n;",
      "    cin >> n;",
      "",
      "    Matrix ans;",
      "    ans.a[0][0] = 0;",
      "    ans.a[0][1] = 1;",
      "    ans.a[1][0] = 1;",
      "    ans.a[1][1] = 1;",
      "",
      "    ans = power(ans, n);",
      "",
      "    cout << ans.a[0][1] << nl;",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    // cin >> test;",
      "    while (test-- > 0){",
      "        solve();",
      "    }",
      "    return 0;",
      "}",
      ""
    ],
    "description": "matrix exponentiation beta"
  },
  "sqrt": {
    "prefix": "sqrt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define nl \"\\n\"",
      "#define big long long",
      "",
      "#ifndef ONLINE_JUDGE",
      "#define ds(statement) cerr << statement << endl",
      "#define dv(var) cerr << (#var) << \": \" << var << endl",
      "#else",
      "#define ds(statement)",
      "#define dv(var)",
      "#endif",
      "",
      "const big MOD = 1e9 + 7;",
      "const big INF = INT64_MAX;",
      "",
      "void build(vector<big> &v, vector<big> &b, big n, big len){",
      "    for (big i = 0; i < n; ++i){",
      "        b[i / len] += v[i];",
      "    }",
      "}",
      "",
      "big query(vector<big> &v, vector<big> &b, big n, big len, big l, big r){",
      "    big sum = 0;",
      "",
      "    big bl = l / len, br = r / len;",
      "",
      "    if (bl == br){",
      "        for (big i = l; i <= r; ++i){",
      "            sum += v[i];",
      "        }",
      "    }",
      "    else{",
      "        for (big i = l; i < (bl + 1) * len; ++i){",
      "            sum += v[i];",
      "        }",
      "        for (big i = bl + 1; i < br; ++i){",
      "            sum += b[i];",
      "        }",
      "        for (big i = br * len; i <= r; ++i){",
      "            sum += v[i];",
      "        }",
      "    }",
      "",
      "    return sum;",
      "}",
      "",
      "void solve(){",
      "    big n;",
      "    cin >> n;",
      "    vector<big> v(n);",
      "",
      "    for (big i = 0; i < n; ++i){",
      "        cin >> v[i];",
      "    }",
      "",
      "    big len = (big)sqrt(1.0 * n) + 1;",
      "    vector<big> b(len);",
      "",
      "    build(v, b, n, len);",
      "}",
      "",
      "int main(){",
      "    ios_base::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    int test = 1;",
      "    cin >> test;",
      "    while (test-- > 0){",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "sqrt decomposition"
  },
  "binlift": {
    "prefix": "binlift",
    "body": [
      "void bin_lift(big n, big lim, vector<vector<big>> &up, vector<big> &par){",
      "    for(big i = 0; i < n; ++i){",
      "        up[i][0] = par[i];    ",
      "    }",
      "",
      "    for(big j = 1; j < lim; ++j){",
      "        for(big i = 0; i < n; ++i){",
      "            if(up[i][j - 1] == -1){",
      "                up[i][j] = -1;",
      "            }else{",
      "                up[i][j] = up[up[i][j - 1]][j - 1];",
      "            }",
      "        }",
      "    }",
      "}"
    ],
    "description": "binlift"
  },
  "lca": {
    "prefix": "lca",
    "body": [
      "// input : tree",
      "// output : binary lifting and lca",
      "struct LCA{",
      "    big n, logn;",
      "    vector<vector<big>> up;",
      "    vector<big> depth, par;",
      "",
      "    LCA(big root, big logn1, G &gr){",
      "        n = gr.g.size();",
      "        logn = logn1;",
      "",
      "        up = vector<vector<big>>(n, vector<big>(logn));",
      "        depth.resize(n);",
      "        par.resize(n);",
      "",
      "        dfs(root, root, gr);",
      "        bin_lift();",
      "    }",
      "",
      "    void dfs(big node, big par1, G &gr){",
      "        par[node] = par1;",
      "",
      "        for(auto nebr : gr.g[node]){",
      "            if(nebr != par1){",
      "                depth[nebr] = depth[node] + 1;",
      "                dfs(nebr, node, gr);",
      "            }",
      "        }",
      "    }",
      "",
      "    void bin_lift(){",
      "        for(big i = 0; i < n; ++i){",
      "            up[i][0] = par[i];    ",
      "        }",
      "",
      "        for(big j = 1; j < logn; ++j){",
      "            for(big i = 0; i < n; ++i){",
      "                up[i][j] = up[up[i][j - 1]][j - 1];",
      "            }",
      "        }",
      "    }",
      "",
      "    big get_lca(big a, big b){",
      "        // bringing a and b at same level",
      "",
      "        if(depth[a] > depth[b]){",
      "            swap(a, b);",
      "        }",
      "        big d = depth[b] - depth[a];",
      "",
      "        for(big j = 0; j < logn && a != -1; ++j){",
      "            if(((1 << j) & d) != 0){",
      "                b = up[b][j];",
      "            }",
      "        }",
      "",
      "        if(a == b){",
      "            return a;",
      "        }",
      "",
      "        // now binary searching for level just lower than LCA",
      "",
      "        for (big j = logn - 1; j >= 0; j--){",
      "            if(up[a][j] != up[b][j]){",
      "                a = up[a][j];",
      "                b = up[b][j];",
      "            }",
      "        }",
      "",
      "        return up[a][0];",
      "    }",
      "};"
    ],
    "description": "lca"
  },
  "centroiddecomposition": {
    "prefix": "centroiddecomposition",
    "body": [
      "// input : a tree",
      "// output : centroid tree and root",
      "struct CD{",
      "    big n, root;",
      "    vector<bool> removed;",
      "    vector<big> size;",
      "    vector<vector<big>> g, centroid_t;",
      "",
      "    CD(big n1){",
      "        n = n1;",
      "        removed.assign(n, false);",
      "        size.resize(n);",
      "        centroid_t.resize(n);",
      "        g.resize(n);",
      "    }",
      "",
      "    void edge(big u, big v){",
      "        g[u].push_back(v);",
      "        g[v].push_back(u);",
      "    }",
      "",
      "    void edge_ct(big u, big v){",
      "        centroid_t[u].push_back(v);",
      "        centroid_t[v].push_back(u);",
      "    }",
      "",
      "    // O(nlogn)",
      "    void decompose(big node, big par){",
      "        get_size(node, -1); // O(n)",
      "",
      "        big c = get_centroid(node, par, size[node]); // O(n)",
      "        removed[c] = true;",
      "",
      "        if(par != -1){",
      "            edge_ct(c, par);",
      "        }",
      "",
      "        for(auto nebr : g[c]){",
      "            if(!removed[nebr]){",
      "                decompose(nebr, c);",
      "            }",
      "        }",
      "",
      "        if(par == -1){",
      "            root = c;",
      "        }",
      "    }",
      "",
      "    big get_size(big node, big par){",
      "        if(removed[node]) return 0;",
      "        size[node] = 1;",
      "",
      "        for(auto nebr : g[node]){",
      "            if(nebr != par){",
      "                size[node] += get_size(nebr, node);",
      "            }",
      "        }",
      "",
      "        return size[node];",
      "    }",
      "",
      "    big get_centroid(big node, big par, big sz){",
      "        for(auto nebr : g[node]){",
      "            if(nebr != par && !removed[nebr] && size[nebr] > sz / 2){",
      "                return get_centroid(nebr, node, sz);",
      "            }",
      "        }",
      "        return node;",
      "    }",
      "};"
    ],
    "description": "centroid decomposition"
  },
  "binaryindexedtree": {
    "prefix": "binaryindexedtree",
    "body": [
      "struct binaryindexedtree{",
      "    big n;",
      "    vector<big> BIT;",
      "",
      "    binaryindexedtree(vector<big> &v){",
      "        n = v.size();",
      "        build(v);",
      "    }",
      "",
      "    big query(big i){",
      "        big sum = 0;",
      "        for(; i > 0; i -= i & -i){",
      "            sum += BIT[i]; ",
      "        }",
      "        return sum;",
      "    }",
      "",
      "    big query(big l, big r){",
      "        return query(r) - query(l - 1);",
      "    }",
      "",
      "    void update(big i, big x){",
      "        for(; i <= n; i += i & -i){",
      "            BIT[i] += x;",
      "        }",
      "    }   ",
      "",
      "    void build(vector<big> &v){",
      "        BIT.assign(n + 1, 0);",
      "        for(big i = 0; i < n; ++i){",
      "            update(i + 1, v[i]);    ",
      "        }",
      "    }",
      "};"
    ],
    "description": "binary indexed tree"
  },
  "eulertourtraversal": {
    "prefix": "eulertourtraversal",
    "body": [
      "struct ETT{",
      "    big t, n, r;",
      "    vector<big> st, end, ett;",
      "",
      "    ETT(big r1, vector<big> &val, G &gr){",
      "        t = 0;",
      "        r = r1;",
      "        n = val.size();",
      "",
      "        st.resize(n);",
      "        end.resize(n);",
      "        ett.reserve(2 * n);",
      "        ",
      "        build(r, -1, val, gr);",
      "    }",
      "",
      "    void build(big node, big par, vector<big> &val, G &gr){",
      "        st[node] = t++;",
      "        ett.push_back(val[node]);",
      "",
      "        for(auto nebr : gr.g[node]){",
      "            if(nebr != par){",
      "                build(nebr, node, val, gr);",
      "            }",
      "        }",
      "",
      "        end[node] = t++;",
      "        ett.push_back(val[node]);",
      "    }",
      "};"
    ],
    "description": "euler tour traversal"
  },
  "lis": {
    "prefix": "lis",
    "body": [
      "void lis(vector<big> &v, vector<big> &dp){",
      "    big n = v.size();",
      "",
      "    // dp[i] = last element in increasing subsequence of length i - 1",
      "    for(big i = 0; i < n; ++i){",
      "        auto it = upper_bound(all(dp), v[i]); ",
      "        if(it == dp.end()){",
      "            dp.push_back(v[i]);",
      "        }else{",
      "            *it = v[i];",
      "        }",
      "    }",
      "}"
    ],
    "description": "lis"
  },
  "graph": {
    "prefix": "graph",
    "body": [
      "struct G{",
      "    vector<vector<big>> g;",
      "    big n;",
      "",
      "    G(big n1){",
      "        n = n1;",
      "        g.resize(n);",
      "    }",
      "",
      "    void uedge(big u, big v){",
      "        g[u].push_back(v);",
      "        g[v].push_back(u);",
      "    }",
      "",
      "    void dedge(big u, big v){",
      "        g[u].push_back(v);",
      "    }",
      "};"
    ],
    "description": "graph"
  },
  "power": {
    "prefix": "power",
    "body": [
      "big power(big base, int exp){",
      "    big res = 1;",
      "    while (exp > 0){",
      "        if (exp & 1){",
      "            res = res * base;",
      "        }",
      "        base *= base;",
      "        exp = exp >> 1;",
      "    }",
      "",
      "    return res;",
      "}"
    ],
    "description": "power"
  },
  "powermod": {
    "prefix": "powermod",
    "body": [
      "// Don't mod this exponent!!",
      "big power(big base, big exp){",
      "\tbase = base % MOD;",
      "    big res = 1;",
      "    while (exp > 0){",
      "        if (exp & 1){",
      "            res = mult(res, base);",
      "        }",
      "        base = mult(base, base);",
      "        exp = exp >> 1;",
      "    }",
      "",
      "    return res;",
      "}"
    ],
    "description": "power mod"
  },
  "addmod": {
    "prefix": "addmod",
    "body": [
      "big add(big a, big b){",
      "\tbig ans = a + b;",
      "\tif(ans >= MOD) ans -= MOD;",
      "\treturn ans;",
      "}"
    ],
    "description": "add mod"
  },
  "submod": {
    "prefix": "submod",
    "body": [
      "big sub(big a, big b){",
      "\tbig ans = a - b;",
      "\tif(ans < 0) ans += MOD;\t",
      "\treturn ans;",
      "}"
    ],
    "description": "subtract mod"
  },
  "multmod": {
    "prefix": "multmod",
    "body": [
      "big mult(big a, big b){",
      "    return (a * 1LL * b) % MOD;",
      "}"
    ],
    "description": "multiply mod"
  },
  "invmod": {
    "prefix": "invmod",
    "body": [
      "big inv(big n){",
      "\treturn power(n, MOD - 2);",
      "}"
    ],
    "description": "inverse mod"
  },
  "divmod": {
    "prefix": "divmod",
    "body": [
      "big divi(big a, big b){",
      "    return mult(a, inv(b));",
      "}"
    ],
    "description": "div mod"
  },
  "ncr": {
    "prefix": "ncr",
    "body": [
      "vector<big> factorials;",
      "vector<big> mmi;",
      "big lim_fac = 1e6 + 1;",
      "",
      "void precompute_factorials(){",
      "    factorials = vector<big>(lim_fac);",
      "    mmi = vector<big>(lim_fac);",
      "    factorials[0] = 1;",
      "    factorials[1] = 1;",
      "    mmi[0] = 1;",
      "    mmi[1] = 1;",
      "",
      "    for (big i = 2; i < lim_fac; ++i){",
      "        factorials[i] = mult(factorials[i - 1], i);",
      "        mmi[i] = inv(factorials[i]);",
      "    }",
      "}",
      "",
      "big ncr(big n, big r){",
      "    if (n < r)",
      "        return 0;",
      "    if (r == 0)",
      "        return 1;",
      "",
      "    big a = factorials[n];",
      "    big b = mmi[r];",
      "    big c = mmi[n - r];",
      "",
      "    big ans = mult(mult(a, b), c);",
      "",
      "    return ans;",
      "}"
    ],
    "description": "ncr"
  },
  "greatestcommondivisor": {
    "prefix": "greatestcommondivisor",
    "body": [
      "big gcd(big a, big b){",
      "    if (b == 0){",
      "        return a;",
      "    }",
      "    return gcd(b, a % b);",
      "}"
    ],
    "description": "gcd"
  },
  "crt": {
    "prefix": "crt",
    "body": [
      "big mult(big a, big b, big mod){",
      "    big ans = 0;",
      "    while (b){",
      "        if (b & 1){",
      "            ans += a;",
      "            ans %= mod;",
      "        }",
      "        a += a;",
      "        a %= mod;",
      "        b >>= 1;",
      "    }",
      "    return ans;",
      "}",
      "",
      "big power(big a, big b, big mod){",
      "    big ans = 1;",
      "    while (b){",
      "        if (b & 1){",
      "            ans = mult(ans, a, mod);",
      "        }",
      "        a = mult(a, a, mod);",
      "        b >>= 1;",
      "    }",
      "    return ans;",
      "}",
      "",
      "big modinv(big a, big mod){",
      "    return power(a, mod - 2, mod);",
      "}",
      "",
      "big crt(vector<big> &p, vector<big> &k){",
      "    big ans = 0; ",
      "    big n = p.size();",
      "",
      "    big prod = 1;",
      "    for (auto x : p){",
      "        prod *= x;",
      "    }",
      "",
      "    for (big i = 0; i < n; ++i){",
      "        big t = 1;",
      "        for (big j = 0; j < i; ++j){",
      "            t *= p[j];",
      "            t *= modinv(p[j], p[i]);",
      "            t %= prod;",
      "        }",
      "        ans += mult(t, k[i] - ans + prod, prod);",
      "        ans %= prod;",
      "    }",
      "",
      "    return ans;",
      "}"
    ],
    "description": "crt"
  },
  "prefixsuffixarray": {
    "prefix": "prefixsuffixarray",
    "body": [
      "struct PSA{",
      "    vector<big> pre, suf;",
      "    big n; ",
      "    ",
      "    PSA(vector<big> &inp){",
      "        n = inp.size();",
      "        pre.resize(n);",
      "        suf.resize(n);",
      "        ",
      "        for(big i = 0; i < n; ++i){",
      "            if(i == 0) pre[i] = inp[i];",
      "            else pre[i] = combine(pre[i - 1], inp[i]);",
      "        }",
      "        for(big i = n - 1; i >= 0; --i){",
      "            if(i == n - 1) suf[i] = inp[i];",
      "            else suf[i] = combine(suf[i + 1], inp[i]);",
      "        }",
      "    }",
      "",
      "    big combine(big a, big b){",
      "        return a + b;",
      "    }",
      "   ",
      "    big pre_query(big i){",
      "        return pre[i];",
      "    }",
      "",
      "    big suf_query(big i){",
      "        return suf[i];",
      "    }",
      "};"
    ],
    "description": "prefix-suffix array"
  },
  "rnd": {
    "prefix": "rnd",
    "body": [
      "big rnd(big a, big b){",
      "    return a + rand() % (b - a + 1);",
      "}"
    ],
    "description": "random numbers"
  },
  "fastinput": {
    "prefix": "fastinput",
    "body": [
      "void fastinput(big &number){",
      "    bool negative = false;",
      "    int c;",
      "",
      "    number = 0;",
      "",
      "    c = getchar();",
      "    if (c == '-'){",
      "        negative = true;",
      "        c = getchar();",
      "    }",
      "",
      "    for (; (c > 47 && c < 58); c = getchar())",
      "        number = number * 10 + c - 48;",
      "",
      "    if (negative)",
      "        number *= -1;",
      "}"
    ],
    "description": "fast input"
  },
  "fileio": {
    "prefix": "fileio",
    "body": [
      "void io_on(){",
      "#ifndef ONLINE_JUDGE",
      "    freopen(\"../input.txt\", \"r\", stdin);",
      "    freopen(\"../output.txt\", \"w\", stdout);",
      "#endif",
      "}"
    ],
    "description": "file io system"
  },
  "query": {
    "prefix": "query",
    "body": [
      "big query(big l, big r){",
      "    cout << \"? \" << l << \" \" << r << endl;",
      "    big sum;",
      "    cin >> sum;",
      "    return sum;",
      "}"
    ],
    "description": "interactive query"
  },
  "structprint": {
    "prefix": "structprint",
    "body": [
      "// place this c",
      "ostream& operator << (ostream &os, const edge &e){",
      "    os << \"(\" << e.a << \", \" << e.b << \", \" << e.c << \")\";",
      "    return os;",
      "}"
    ],
    "description": "struct print"
  },
  "mprint": {
    "prefix": "mprint",
    "body": [
      "template <typename T, typename S>",
      "ostream &operator<<(ostream &os, map<T, S> &v){",
      "    auto endit = v.end();",
      "    endit--;",
      "    os << \"{\";",
      "    for (auto it = v.begin(); it != v.end(); it++){",
      "        os << \"(\" << (*it).first << \" : \" << (*it).second << \")\";",
      "        if (it != endit){",
      "            os << \", \";",
      "        }",
      "    }",
      "    os << \"}\";",
      "    return os;",
      "}"
    ],
    "description": "map print"
  },
  "msprint": {
    "prefix": "msprint",
    "body": [
      "template <typename T>",
      "ostream &operator<<(ostream &os, multiset<T> &v){",
      "    auto endit = v.end();",
      "    endit--;",
      "    os << \"[\";",
      "    for (auto it = v.begin(); it != v.end(); it++){",
      "        os << *it;",
      "        if (it != endit){",
      "            os << \", \";",
      "        }",
      "    }",
      "    os << \"]\";",
      "    return os;",
      "}"
    ],
    "description": "multiset print"
  },
  "sprint": {
    "prefix": "sprint",
    "body": [
      "template <typename T>",
      "ostream &operator<<(ostream &os, set<T> &v){",
      "    auto endit = v.end();",
      "    endit--;",
      "    os << \"[\";",
      "    for (auto it = v.begin(); it != v.end(); it++){",
      "        os << *it;",
      "        if (it != endit){",
      "            os << \", \";",
      "        }",
      "    }",
      "    os << \"]\";",
      "    return os;",
      "}"
    ],
    "description": "set print"
  },
  "tprint": {
    "prefix": "tprint",
    "body": [
      "template <typename T, typename S, typename Q>",
      "ostream &operator<<(ostream &os, tuple<T, S, Q> &t){",
      "    os << \"(\" << get<0>(t) << \", \" << get<1>(t) << \", \"<<get<2>(t) << \")\";",
      "    return os;",
      "}"
    ],
    "description": "tuple print"
  },
  "pprint": {
    "prefix": "pprint",
    "body": [
      "template <typename T, typename S>",
      "ostream &operator<<(ostream &os, pair<T, S> &p){",
      "    os << \"(\" << p.first << \", \" << p.second << \")\";",
      "    return os;",
      "}"
    ],
    "description": "pair print"
  },
  "vprint": {
    "prefix": "vprint",
    "body": [
      "template <typename T>",
      "ostream &operator<<(ostream &os, vector<T> &v){",
      "    for (auto element : v){",
      "        os << element << \" \";",
      "    }",
      "    return os;",
      "}"
    ],
    "description": "vector print"
  },
  "vsort": {
    "prefix": "vsort",
    "body": [
      "sort(all(${1:vector}));"
    ],
    "description": "sort vector"
  },
  "vsortrev": {
    "prefix": "vsortrev",
    "body": [
      "sort(all(${1:vector}), greater<${2:big}>());"
    ],
    "description": "sort vector reverse"
  },
  "fr": {
    "prefix": "fr",
    "body": [
      "for(${4:big} ${1:element} = ${2:start}; $1 < ${3:size}; ++$1){",
      "    ${5}",
      "}"
    ],
    "description": "for"
  },
  "fre": {
    "prefix": "fre",
    "body": [
      "for(${4:big} ${1:element} = ${2:start}; $1 <= ${3:size}; ++$1){",
      "    ${5}",
      "}"
    ],
    "description": "for equals"
  },
  "rfr": {
    "prefix": "rfr",
    "body": [
      "for (${3:big} ${1:element} = ${2:size} - 1; $1 >= 0; --$1){",
      "    ${4}",
      "}"
    ],
    "description": "reverse for"
  },
  "rfre": {
    "prefix": "rfre",
    "body": [
      "for (${3:big} ${1:element} = ${2:size}; $1 >= 1; --$1){",
      "    ${4}",
      "}"
    ],
    "description": "reverse for equals"
  },
  "tcgen": {
    "prefix": "tcgen",
    "body": [
      "struct testcase_generator{",
      "    big rnd(big a, big b) {",
      "        return a + rand() % (b - a + 1);",
      "    }",
      "",
      "    struct DSU{",
      "        vector<big> par, size;    ",
      "        big num_comps;",
      "",
      "        DSU(big n){",
      "            size.assign(n, 1);",
      "            par.resize(n);",
      "            iota(all(par), 0);",
      "            num_comps = n;",
      "        }",
      "",
      "        void union_(big a, big b){",
      "            a = find(a);",
      "            b = find(b);",
      "",
      "            if (a != b){",
      "                num_comps--;",
      "",
      "                if (size[a] < size[b]) swap(a, b);",
      "                par[b] = a;",
      "                size[a] += size[b];",
      "            }",
      "        }   ",
      "",
      "        big find(big node){",
      "            if(par[node] != node) par[node] = find(par[node]);",
      "            return par[node];",
      "        }",
      "    };",
      "",
      "    void generate_tree(big n){",
      "        DSU dsu = DSU(n);",
      "        vector<pair<big, big>> tree_edges;",
      "        tree_edges.reserve(n - 1);",
      "",
      "        while(dsu.num_comps > 1){",
      "            big a = rnd(0, n - 1);",
      "            big b = rnd(0, n - 1);",
      "",
      "            if(dsu.find(a) != dsu.find(b)){",
      "                tree_edges.push_back({a, b});",
      "                dsu.union_(a, b);",
      "            }",
      "        }",
      "",
      "        for(big i = 0; i < n - 1; ++i){",
      "            cout << tree_edges[i].first + 1 << \" \" << tree_edges[i].second + 1 << nl;",
      "        }",
      "    }",
      "    ",
      "    void generate_array(big n, big lower_limit, big upper_limit){",
      "        for(big i = 0; i < n; ++i){",
      "            cout << rnd(lower_limit, upper_limit) << \" \";",
      "        }",
      "        cout << nl;",
      "    }",
      "",
      "    void generate_set(big n, big lower_limit, big upper_limit){",
      "        set<big> s;",
      "        for(big i = 0; i < n; ++i){",
      "            big x;    ",
      "            do{",
      "                x = rnd(lower_limit, upper_limit);",
      "            }while(s.count(x) > 0);",
      "            s.insert(x);",
      "            cout << x << \" \";",
      "        }",
      "        cout << nl;",
      "    }",
      "};"
    ],
    "description": "testcase generator"
  }
}
