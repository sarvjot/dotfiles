{
	"lower_common_ancestor": {
		"prefix": "lca",
		"body": [
			"struct LCA{",
			"\tbig n, logn;",
			"\tvector<vector<big>> up;",
			"\tvector<big> depth, par;",
			"",
			"\tLCA(big root, big logn1, G &gr){",
			"\t\tn = gr.g.size();",
			"\t\tlogn = logn1;",
			"",
			"\t\tup = vector<vector<big>>(n, vector<big>(logn));",
			"\t\tdepth.resize(n);",
			"\t\tpar.resize(n);",
			"",
			"\t\tdfs(root, root, gr);",
			"\t\tbin_lift();",
			"\t}",
			"",
			"\tvoid dfs(big node, big par1, G &gr){",
			"\t\tpar[node] = par1;",
			"",
			"\t\tfor(auto nebr : gr.g[node]){",
			"\t\t\tif(nebr != par1){",
			"\t\t\t\tdepth[nebr] = depth[node] + 1;",
			"\t\t\t\tdfs(nebr, node, gr);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tvoid bin_lift(){",
			"\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\tup[i][0] = par[i];    ",
			"\t\t}",
			"",
			"\t\tfor(big j = 1; j < logn; ++j){",
			"\t\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\t\tup[i][j] = up[up[i][j - 1]][j - 1];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\tbig get_lca(big a, big b){",
			"\t\t// bringing a and b at same level",
			"",
			"\t\tif(depth[a] > depth[b]){",
			"\t\t\tswap(a, b);",
			"\t\t}",
			"\t\tbig d = depth[b] - depth[a];",
			"",
			"\t\tfor(big j = 0; j < logn && a != -1; ++j){",
			"\t\t\tif(((1 << j) & d) != 0){",
			"\t\t\t\tb = up[b][j];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif(a == b){",
			"\t\t\treturn a;",
			"\t\t}",
			"",
			"\t\t// now binary searching for level just lower than LCA",
			"",
			"\t\tfor (big j = logn - 1; j >= 0; j--){",
			"\t\t\tif(up[a][j] != up[b][j]){",
			"\t\t\t\ta = up[a][j];",
			"\t\t\t\tb = up[b][j];",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\treturn up[a][0];",
			"\t}",
			"};"
		],
		"description": "get lca of two nodes in a tree, binary lifting is a byproduct"
	},
	"sqrt_decomposition": {
		"prefix": "sqrtdecomposition",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define nl \"\\n\"",
			"#define big long long",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define ds(statement) cerr << statement << endl",
			"#define dv(var) cerr << (#var) << \": \" << var << endl",
			"#else",
			"#define ds(statement)",
			"#define dv(var)",
			"#endif",
			"",
			"const big MOD = 1e9 + 7;",
			"const big INF = INT64_MAX;",
			"",
			"void build(vector<big> &v, vector<big> &b, big n, big len){",
			"\tfor (big i = 0; i < n; ++i){",
			"\t\tb[i / len] += v[i];",
			"\t}",
			"}",
			"",
			"big query(vector<big> &v, vector<big> &b, big n, big len, big l, big r){",
			"\tbig sum = 0;",
			"",
			"\tbig bl = l / len, br = r / len;",
			"",
			"\tif (bl == br){",
			"\t\tfor (big i = l; i <= r; ++i){",
			"\t\t\tsum += v[i];",
			"\t\t}",
			"\t}",
			"\telse{",
			"\t\tfor (big i = l; i < (bl + 1) * len; ++i){",
			"\t\t\tsum += v[i];",
			"\t\t}",
			"\t\tfor (big i = bl + 1; i < br; ++i){",
			"\t\t\tsum += b[i];",
			"\t\t}",
			"\t\tfor (big i = br * len; i <= r; ++i){",
			"\t\t\tsum += v[i];",
			"\t\t}",
			"\t}",
			"",
			"\treturn sum;",
			"}",
			"",
			"void solve(){",
			"\tbig n;",
			"\tcin >> n;",
			"\tvector<big> v(n);",
			"",
			"\tfor (big i = 0; i < n; ++i){",
			"\t\tcin >> v[i];",
			"\t}",
			"",
			"\tbig len = (big)sqrt(1.0 * n) + 1;",
			"\tvector<big> b(len);",
			"",
			"\tbuild(v, b, n, len);",
			"}",
			"",
			"int main(){",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint test = 1;",
			"\tcin >> test;",
			"\twhile (test-- > 0){",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "square root decomposition"
	},
	"barebones_boilerplate": {
		"prefix": "barebonesboilerplate",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"void solve(){",
			"",
			"}",
			"",
			"int main(){",
			"\tint test;",
			"\tcin >> test;",
			"\tfor (int i = 1; i <= test; ++i){",
			"\t\tsolve();",
			"\t}",
			"}"
		],
		"description": "barebones boilerplate for online assessments"
	},
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"template<typename T>char delim_fun(T t){string s=typeid(t).name();set<string>st={\"set\", \"vector\",\"map\"};for(auto a:st){if(s.find(a)!=std::string::npos)return'\\n';}return' ';}",
			"template<typename T,typename S,typename Q>ostream &operator<<(ostream &os,tuple<T,S,Q> &t){os<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\")\";return os;}",
			"template<typename T,typename S>ostream &operator<<(ostream &os,pair<T,S>&p){os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";return os;}",
			"template<typename T,typename S>ostream &operator<<(ostream &os,map<T,S>&v){os<<\"[ \";for(auto it=v.begin();it!=v.end();it++){os<<\"(\"<<(*it).first<<\", \"<<(*it).second <<\") \";}os <<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,vector<T>&v){char ch=delim_fun(v[0]);if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,set<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,multiset<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename...Args>void logger(string vars,Args&&...values){cerr<<\"\\033[31m\"<<vars<<\" : \";string delim;(...,(cerr<<delim<<values,delim=\", \"));cerr<<\"\\033[37m\"<<endl;}",
			"",
			"#define nl \"\\n\"",
			"#define big long long",
			"#define all(x) (x).begin(), (x).end()",
			"#define precision(x) fixed << setprecision(x)",
			"#define get_set_bits(x) __builtin_popcountll(x) ",
			"#define ordered tree<big, null_type, less<big>, rb_tree_tag, tree_order_statistics_node_update>",
			"#define ordered_ms tree<pair<big, big>, null_type, less<pair<big, big>>, rb_tree_tag, tree_order_statistics_node_update>",
			"",
			"#ifdef SARVJOT ",
			"#define ds(statement) cerr << \"\\033[32m\" << statement << \"\\033[37m\" << endl",
			"#define dv(args...) logger(#args, args)",
			"#define sm_line  cerr << \"\\033[33m\" << \"---------X--------\" << \"\\033[37m\" << endl",
			"#define lg_line  cerr << \"\\033[34m\" << \"------X----------X------\" << \"\\033[37m\" << endl",
			"void print_pbds(ordered &v){cerr<<\"\\033[31m\"<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<\"\\033[37m\"<<endl;}",
			"void print_pbdsms(ordered_ms &v){cerr<<\"\\033[31m\"<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<\"\\033[37m\"<<endl;}",
			"#else",
			"#define ds(statement)",
			"#define dv(...)",
			"#define sm_line",
			"#define lg_line",
			"void print_pbds(ordered &v){;}",
			"void print_pbdsms(ordered_ms &v){;}",
			"#endif",
			"",
			"const big INF = INT64_MAX;",
			"",
			"void solve(){",
			"\tbig n;",
			"\tcin >> n;",
			"\tvector<big> v(n);",
			"",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tcin >> v[i];",
			"\t}",
			"}",
			"",
			"int main(){",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint test = 1;",
			"\tcin >> test;",
			"\tfor (int i = 1; i <= test; ++i){",
			"\t\t//cout << \"Case #\" << i << \": \";",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "boilerplate for competitive programming"
	},
	"binary_lifting": {
		"prefix": "binlift",
		"body": [
			"void bin_lift(big n, big lim, vector<vector<big>> &up, vector<big> &par){",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tup[i][0] = par[i];    ",
			"\t}",
			"",
			"\tfor(big j = 1; j < lim; ++j){",
			"\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\tif(up[i][j - 1] == -1){",
			"\t\t\t\tup[i][j] = -1;",
			"\t\t\t}else{",
			"\t\t\t\tup[i][j] = up[up[i][j - 1]][j - 1];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "binary lifting"
	},
	"euclidean_gcd": {
		"prefix": "greatestcommondivisor",
		"body": [
			"big gcd(big a, big b){",
			"\tif (b == 0){",
			"\t\treturn a;",
			"\t}",
			"\treturn gcd(b, a % b);",
			"}"
		],
		"description": "greatest common divisor of two numbers"
	},
	"centroid_decomposition": {
		"prefix": "centroiddecomposition",
		"body": [
			"struct CD{",
			"\tbig n, root;",
			"\tvector<bool> removed;",
			"\tvector<big> size;",
			"\tvector<vector<big>> g, centroid_t;",
			"",
			"\tCD(big n1){",
			"\t\tn = n1;",
			"\t\tremoved.assign(n, false);",
			"\t\tsize.resize(n);",
			"\t\tcentroid_t.resize(n);",
			"\t\tg.resize(n);",
			"\t}",
			"",
			"\tvoid edge(big u, big v){",
			"\t\tg[u].push_back(v);",
			"\t\tg[v].push_back(u);",
			"\t}",
			"",
			"\tvoid edge_ct(big u, big v){",
			"\t\tcentroid_t[u].push_back(v);",
			"\t\tcentroid_t[v].push_back(u);",
			"\t}",
			"",
			"\t// O(nlogn)",
			"\tvoid decompose(big node, big par){",
			"\t\tget_size(node, -1); // O(n)",
			"",
			"\t\tbig c = get_centroid(node, par, size[node]); // O(n)",
			"\t\tremoved[c] = true;",
			"",
			"\t\tif(par != -1){",
			"\t\t\tedge_ct(c, par);",
			"\t\t}",
			"",
			"\t\tfor(auto nebr : g[c]){",
			"\t\t\tif(!removed[nebr]){",
			"\t\t\t\tdecompose(nebr, c);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tif(par == -1){",
			"\t\t\troot = c;",
			"\t\t}",
			"\t}",
			"",
			"\tbig get_size(big node, big par){",
			"\t\tif(removed[node]) return 0;",
			"\t\tsize[node] = 1;",
			"",
			"\t\tfor(auto nebr : g[node]){",
			"\t\t\tif(nebr != par){",
			"\t\t\t\tsize[node] += get_size(nebr, node);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\treturn size[node];",
			"\t}",
			"",
			"\tbig get_centroid(big node, big par, big sz){",
			"\t\tfor(auto nebr : g[node]){",
			"\t\t\tif(nebr != par && !removed[nebr] && size[nebr] > sz / 2){",
			"\t\t\t\treturn get_centroid(nebr, node, sz);",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn node;",
			"\t}",
			"};"
		],
		"description": "takes a tree and decomposes it into a centroid tree and root"
	},
	"boilerplate_no_color": {
		"prefix": "boilerplatenocolor",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"template<typename T>char delim_fun(T t){string s=typeid(t).name();set<string>st={\"set\", \"vector\",\"map\"};for(auto a:st){if(s.find(a)!=std::string::npos)return'\\n';}return' ';}",
			"template<typename T,typename S,typename Q>ostream &operator<<(ostream &os,tuple<T,S,Q> &t){os<<\"(\"<<get<0>(t)<<\", \"<<get<1>(t)<<\", \"<<get<2>(t)<<\")\";return os;}",
			"template<typename T,typename S>ostream &operator<<(ostream &os,pair<T,S>&p){os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";return os;}",
			"template<typename T,typename S>ostream &operator<<(ostream &os,map<T,S>&v){os<<\"[ \";for(auto it=v.begin();it!=v.end();it++){os<<\"(\"<<(*it).first<<\", \"<<(*it).second <<\") \";}os <<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,vector<T>&v){char ch=delim_fun(v[0]);if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,set<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename T>ostream &operator<<(ostream &os,multiset<T> &v){char ch=delim_fun(*(v.begin()));if(ch==' ')os<<\"[ \";for(auto element:v){os<<element;os<<ch;}if(ch==' ')os<<\"]\";return os;}",
			"template<typename...Args>void logger(string vars,Args&&...values){cerr<<vars<<\" : \";string delim;(...,(cerr<<delim<<values,delim=\", \"));cerr<<endl;}",
			"",
			"#define nl \"\\n\"",
			"#define big long long",
			"#define all(x) (x).begin(), (x).end()",
			"#define precision(x) fixed << setprecision(x)",
			"#define get_set_bits(x) __builtin_popcountll(x) ",
			"#define ordered tree<big, null_type, less<big>, rb_tree_tag, tree_order_statistics_node_update>",
			"#define ordered_ms tree<pair<big, big>, null_type, less<pair<big, big>>, rb_tree_tag, tree_order_statistics_node_update>",
			"",
			"#ifdef SARVJOT ",
			"#define ds(statement) cerr << statement << endl",
			"#define dv(args...) logger(#args, args)",
			"#define sm_line  cerr << \"---------X--------\" << endl",
			"#define lg_line  cerr << \"------X----------X------\" << endl",
			"void print_pbds(ordered &v){cerr<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<endl;}",
			"void print_pbdsms(ordered_ms &v){cerr<<\"[ \";for(auto a:v){cerr<<a<<\" \";}cerr<<\"]\"<<endl;}",
			"#else",
			"#define ds(statement)",
			"#define dv(...)",
			"#define sm_line",
			"#define lg_line",
			"void print_pbds(ordered &v){;}",
			"void print_pbdsms(ordered_ms &v){;}",
			"#endif",
			"",
			"const big INF = INT64_MAX;",
			"",
			"void solve(){",
			"\tbig n;",
			"\tcin >> n;",
			"\tvector<big> v(n);",
			"",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tcin >> v[i];",
			"\t}",
			"}",
			"",
			"int main(){",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint test = 1;",
			"\tcin >> test;",
			"\tfor (int i = 1; i <= test; ++i){",
			"\t\t//cout << \"Case #\" << i << \": \";",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "boilerplate for competitive programming (no color)"
	},
	"knuth_morris_pratt": {
		"prefix": "kmp",
		"body": [
			"void prefix_function(char *s, vector<big> &pi){",
			"\tbig m = (big)pi.size();",
			"\tfor (big i = 1; i < m; ++i){",
			"\t\tbig j = pi[i - 1];",
			"",
			"\t\twhile (j > 0 && s[i] != s[j]){",
			"\t\t\tj = pi[j - 1];",
			"\t\t}",
			"",
			"\t\tif (s[i] == s[j]){",
			"\t\t\t++j;",
			"\t\t}",
			"",
			"\t\tpi[i] = j;",
			"\t}",
			"}",
			"",
			"void kmp(char *pat, char *txt){",
			"\tbig m = strlen(pat);",
			"\tbig n = strlen(txt);",
			"",
			"\tvector<big> pi(m);",
			"\tprefix_function(pat, pi);",
			"",
			"\tbig i = 0, j = 0;",
			"",
			"\twhile (i < n){",
			"\t\tif (pat[j] == txt[i]){",
			"\t\t\t++i;",
			"\t\t\t++j;",
			"\t\t}",
			"",
			"\t\tif (j == m){",
			"\t\t\tcout << (i - j) << \" \";",
			"\t\t\tj = pi[j - 1];",
			"\t\t}",
			"\t\telse if (i < n && pat[j] != txt[i]){",
			"\t\t\tif (j != 0){",
			"\t\t\t\tj = pi[j - 1];",
			"\t\t\t}",
			"\t\t\telse{",
			"\t\t\t\t++i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "knuth morris pratt algorithm for pattern matching [O(n + m)]"
	},
	"matrix_exponentiation": {
		"prefix": "matrixexponentiation",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define nl \"\\n\"",
			"#define big long long",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define ds(statement) cerr << statement << endl",
			"#define dv(var) cerr << (#var) << \": \" << var << endl",
			"#else",
			"#define ds(statement)",
			"#define dv(var)",
			"#endif",
			"",
			"const big MOD = 1e9 + 7;",
			"const big INF = INT64_MAX;",
			"",
			"big add(big a, big b){",
			"\tbig ans = a + b;",
			"\tif(ans >= MOD) ans -= MOD;",
			"\treturn ans;",
			"}",
			"",
			"big mult(big a, big b){",
			"\treturn (a * 1LL * b) % MOD;",
			"}",
			"",
			"struct Matrix{",
			"\tbig a[2][2] = {{0, 0}, {0, 0}};",
			"\tMatrix operator*(const Matrix &other){",
			"\t\tMatrix prod;",
			"\t\tfor (big i = 0; i < 2; ++i){",
			"\t\t\tfor (big j = 0; j < 2; ++j){",
			"\t\t\t\tfor (big k = 0; k < 2; ++k){",
			"\t\t\t\t\tprod.a[i][j] = add(prod.a[i][j], mult(a[i][k], other.a[k][j]));",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn prod;",
			"\t}",
			"};",
			"",
			"Matrix power(Matrix a, big k){",
			"\tMatrix prod;",
			"",
			"\tfor (int i = 0; i < 2; ++i){",
			"\t\tprod.a[i][i] = 1;",
			"\t}",
			"",
			"\twhile (k > 0){",
			"\t\tif (k % 2 == 1){",
			"\t\t\tprod = prod * a;",
			"\t\t}",
			"\t\ta = a * a;",
			"\t\tk /= 2;",
			"\t}",
			"",
			"\treturn prod;",
			"}",
			"",
			"void solve(){",
			"\tbig n;",
			"\tcin >> n;",
			"",
			"\tMatrix ans;",
			"\tans.a[0][0] = 0;",
			"\tans.a[0][1] = 1;",
			"\tans.a[1][0] = 1;",
			"\tans.a[1][1] = 1;",
			"",
			"\tans = power(ans, n);",
			"",
			"\tcout << ans.a[0][1] << nl;",
			"}",
			"",
			"int main(){",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint test = 1;",
			"\t// cin >> test;",
			"\twhile (test-- > 0){",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "matrix exponentiation"
	},
	"trie": {
		"prefix": "trie",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define nl \"\\n\"",
			"#define big long long",
			"",
			"#ifndef ONLINE_JUDGE",
			"#define ds(statement) cerr << statement << endl",
			"#define dv(var) cerr << (#var) << \": \" << var << endl",
			"#else",
			"#define ds(statement)",
			"#define dv(var)",
			"#endif",
			"",
			"const big MOD = 1e9 + 7;",
			"const big INF = INT64_MAX;",
			"",
			"struct trie{",
			"\tvector<trie *> children;",
			"",
			"\ttrie(){",
			"\t\tchildren = vector<trie *>(26, NULL);",
			"\t}",
			"};",
			"",
			"trie *root;",
			"",
			"void insert(string &str){",
			"\ttrie *cur = root;",
			"",
			"\tfor (char ch : str){",
			"\t\tbig ind = ch - 'a';",
			"",
			"\t\tif (cur->children[ind] == NULL){",
			"\t\t\tcur->children[ind] = new trie;",
			"\t\t}",
			"",
			"\t\tcur = cur->children[ind];",
			"\t}",
			"}",
			"",
			"void generate_trie(string &str){",
			"\tbig n = str.size();",
			"\tfor (big i = 0; i < n; ++i){",
			"\t\tstring t = str.substr(i);",
			"\t\tinsert(t);",
			"\t}",
			"}",
			"",
			"big dfs_trie(string &s, trie *cur, big k){",
			"\tbig ans = 0;",
			"",
			"\tif (cur != root){",
			"\t\tans = 1;",
			"\t}",
			"",
			"\tfor (big i = 0; i < 26; ++i){",
			"\t\tif (cur->children[i] != NULL){",
			"\t\t\tif (s[i] == '0'){",
			"\t\t\t\tif (k > 0){",
			"\t\t\t\t\tans += dfs_trie(s, cur->children[i], k - 1);",
			"\t\t\t\t}",
			"\t\t\t}",
			"\t\t\telse{",
			"\t\t\t\tans += dfs_trie(s, cur->children[i], k);",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\treturn ans;",
			"}",
			"",
			"void solve(){",
			"\troot = new trie();",
			"",
			"\tstring s1, s2;",
			"\tbig k;",
			"\tcin >> s1 >> s2 >> k;",
			"",
			"\tgenerate_trie(s1);",
			"\tbig ans = dfs_trie(s2, root, k);",
			"",
			"\tcout << ans << nl;",
			"}",
			"",
			"int main(){",
			"\tios_base::sync_with_stdio(false);",
			"\tcin.tie(NULL);",
			"\tint test = 1;",
			"\t// cin >> test;",
			"\twhile (test-- > 0){",
			"\t\tsolve();",
			"\t}",
			"\treturn 0;",
			"}"
		],
		"description": "trie data structure"
	},
	"test_case_generator": {
		"prefix": "tcgen",
		"body": [
			"struct testcase_generator{",
			"\tbig rnd(big a, big b) {",
			"\t\treturn a + rand() % (b - a + 1);",
			"\t}",
			"",
			"\tstruct DSU{",
			"\t\tvector<big> par, size;    ",
			"\t\tbig num_comps;",
			"",
			"\t\tDSU(big n){",
			"\t\t\tsize.assign(n, 1);",
			"\t\t\tpar.resize(n);",
			"\t\t\tiota(all(par), 0);",
			"\t\t\tnum_comps = n;",
			"\t\t}",
			"",
			"\t\tvoid union_(big a, big b){",
			"\t\t\ta = find(a);",
			"\t\t\tb = find(b);",
			"",
			"\t\t\tif (a != b){",
			"\t\t\t\tnum_comps--;",
			"",
			"\t\t\t\tif (size[a] < size[b]) swap(a, b);",
			"\t\t\t\tpar[b] = a;",
			"\t\t\t\tsize[a] += size[b];",
			"\t\t\t}",
			"\t\t}   ",
			"",
			"\t\tbig find(big node){",
			"\t\t\tif(par[node] != node) par[node] = find(par[node]);",
			"\t\t\treturn par[node];",
			"\t\t}",
			"\t};",
			"",
			"\tvoid generate_tree(big n){",
			"\t\tDSU dsu = DSU(n);",
			"\t\tvector<pair<big, big>> tree_edges;",
			"\t\ttree_edges.reserve(n - 1);",
			"",
			"\t\twhile(dsu.num_comps > 1){",
			"\t\t\tbig a = rnd(0, n - 1);",
			"\t\t\tbig b = rnd(0, n - 1);",
			"",
			"\t\t\tif(dsu.find(a) != dsu.find(b)){",
			"\t\t\t\ttree_edges.push_back({a, b});",
			"\t\t\t\tdsu.union_(a, b);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tfor(big i = 0; i < n - 1; ++i){",
			"\t\t\tcout << tree_edges[i].first + 1 << \" \" << tree_edges[i].second + 1 << nl;",
			"\t\t}",
			"\t}",
			"\t",
			"\tvoid generate_array(big n, big lower_limit, big upper_limit){",
			"\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\tcout << rnd(lower_limit, upper_limit) << \" \";",
			"\t\t}",
			"\t\tcout << nl;",
			"\t}",
			"",
			"\tvoid generate_set(big n, big lower_limit, big upper_limit){",
			"\t\tset<big> s;",
			"\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\tbig x;    ",
			"\t\t\tdo{",
			"\t\t\t\tx = rnd(lower_limit, upper_limit);",
			"\t\t\t}while(s.count(x) > 0);",
			"\t\t\ts.insert(x);",
			"\t\t\tcout << x << \" \";",
			"\t\t}",
			"\t\tcout << nl;",
			"\t}",
			"};"
		],
		"description": "test case generator for problems"
	},
	"binary_exponentiation": {
		"prefix": "powerbinexp",
		"body": [
			"big power(big base, int exp){",
			"\tbig res = 1;",
			"\twhile (exp > 0){",
			"\t\tif (exp & 1){",
			"\t\t\tres = res * base;",
			"\t\t}",
			"\t\tbase *= base;",
			"\t\texp = exp >> 1;",
			"\t}",
			"",
			"\treturn res;",
			"}"
		],
		"description": "binary exponentiation"
	},
	"ncr": {
		"prefix": "ncr",
		"body": [
			"vector<big> factorials;",
			"vector<big> mmi;",
			"big lim_fac = 1e6 + 1;",
			"",
			"void precompute_factorials(){",
			"\tfactorials = vector<big>(lim_fac);",
			"\tmmi = vector<big>(lim_fac);",
			"\tfactorials[0] = 1;",
			"\tfactorials[1] = 1;",
			"\tmmi[0] = 1;",
			"\tmmi[1] = 1;",
			"",
			"\tfor (big i = 2; i < lim_fac; ++i){",
			"\t\tfactorials[i] = mult(factorials[i - 1], i);",
			"\t\tmmi[i] = inv(factorials[i]);",
			"\t}",
			"}",
			"",
			"big ncr(big n, big r){",
			"\tif (n < r)",
			"\t\treturn 0;",
			"\tif (r == 0)",
			"\t\treturn 1;",
			"",
			"\tbig a = factorials[n];",
			"\tbig b = mmi[r];",
			"\tbig c = mmi[n - r];",
			"",
			"\tbig ans = mult(mult(a, b), c);",
			"",
			"\treturn ans;",
			"}"
		],
		"description": "out of n objects, choose r objects"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
			"struct edge{",
			"\tbig a, b, c;",
			"",
			"\tbool operator < (const edge &other){",
			"\t\treturn c < other.c;",
			"\t}",
			"\t",
			"};",
			"",
			"struct kruskal{",
			"\tstruct DSU{",
			"\t\tvector<big> par, size;    ",
			"\t\tbig num_comps;",
			"\t",
			"\t\tDSU(big n){",
			"\t\t\tsize.assign(n, 1);",
			"\t\t\tpar.resize(n);",
			"\t\t\tiota(all(par), 0);",
			"\t\t\tnum_comps = n;",
			"\t\t}",
			"\t",
			"\t\tvoid union_(big a, big b){",
			"\t\t\ta = find(a);",
			"\t\t\tb = find(b);",
			"\t",
			"\t\t\tif (a != b){",
			"\t\t\t\tnum_comps--;",
			"\t",
			"\t\t\t\tif (size[a] < size[b]) swap(a, b);",
			"\t\t\t\tpar[b] = a;",
			"\t\t\t\tsize[a] += size[b];",
			"\t\t\t}",
			"\t\t}   ",
			"\t",
			"\t\tbig find(big node){",
			"\t\t\tif(par[node] != node) par[node] = find(par[node]);",
			"\t\t\treturn par[node];",
			"\t\t}",
			"\t}; ",
			"",
			"\tvector<edge> g, t;",
			"\tbig n, cost, pos;",
			"",
			"\tkruskal(big n1){",
			"\t\tcost = 0;",
			"\t\tpos = 1;",
			"\t\tn = n1;",
			"\t}",
			"",
			"\tvoid init(){",
			"\t\tassert((big)g.size() == n);",
			"",
			"\t\tDSU dsu_s(n);",
			"\t\tsort(all(g));",
			"",
			"\t\tfor(auto &e : g){",
			"\t\t\tif(dsu_s.find(e.a) != dsu_s.find(e.b)){",
			"\t\t\t\tdsu_s.union_(e.a, e.b);",
			"\t\t\t\tcost += e.c;",
			"\t\t\t\tt.push_back(e);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\t// check if its possible to generate a MST",
			"\t\tbig p = dsu_s.find(0);",
			"\t\tfor(big i = 1; i < n; ++i){",
			"\t\t\tbig cp = dsu_s.find(i); ",
			"\t\t\tif(cp != p){",
			"\t\t\t\tpos = 0;",
			"\t\t\t\tbreak;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "kruskal's algorithm for finding the minimum spanning tree of a graph"
	},
	"binary_indexed_tree": {
		"prefix": "binaryindexedtree",
		"body": [
			"struct binaryindexedtree{",
			"\tbig n;",
			"\tvector<big> BIT;",
			"",
			"\tbinaryindexedtree(vector<big> &v){",
			"\t\tn = v.size();",
			"\t\tbuild(v);",
			"\t}",
			"",
			"\tbig query(big i){",
			"\t\tbig sum = 0;",
			"\t\tfor(; i > 0; i -= i & -i){",
			"\t\t\tsum += BIT[i]; ",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"",
			"\tbig query(big l, big r){",
			"\t\treturn query(r) - query(l - 1);",
			"\t}",
			"",
			"\tvoid update(big i, big x){",
			"\t\tfor(; i <= n; i += i & -i){",
			"\t\t\tBIT[i] += x;",
			"\t\t}",
			"\t}   ",
			"",
			"\tvoid build(vector<big> &v){",
			"\t\tBIT.assign(n + 1, 0);",
			"\t\tfor(big i = 0; i < n; ++i){",
			"\t\t\tupdate(i + 1, v[i]);    ",
			"\t\t}",
			"\t}",
			"};"
		],
		"description": "binary indexed tree/fenwick tree"
	},
	"modular_suite": {
		"prefix": "modsuite",
		"body": [
			"const big MOD = 1e9 + 7;",
			"",
			"big add(big a, big b){",
			"\tbig ans = a + b;",
			"\tif(ans >= MOD) ans -= MOD;",
			"\treturn ans;",
			"}",
			"",
			"big sub(big a, big b){",
			"\tbig ans = a - b;",
			"\tif(ans < 0) ans += MOD;\t",
			"\treturn ans;",
			"}",
			"",
			"big mult(big a, big b){",
			"\treturn (a * 1LL * b) % MOD;",
			"}",
			"",
			"// Don't mod this exponent!!",
			"big power(big base, big exp){",
			"\tbase = base % MOD;",
			"\tbig res = 1;",
			"\twhile (exp > 0){",
			"\t\tif (exp & 1){",
			"\t\t\tres = mult(res, base);",
			"\t\t}",
			"\t\tbase = mult(base, base);",
			"\t\texp = exp >> 1;",
			"\t}",
			"",
			"\treturn res;",
			"}",
			"",
			"big inv(big n){",
			"\treturn power(n, MOD - 2);",
			"}",
			"",
			"big divi(big a, big b){",
			"\treturn mult(a, inv(b));",
			"}"
		],
		"description": "modular arithmetic suite of functions"
	},
	"sieve_of_eratosthenes": {
		"prefix": "sieve",
		"body": [
			"big lim = 1e6;",
			"vector<bool> sieve(lim + 1, true);",
			"vector<big> sieveCount(lim + 1, 0);",
			"vector<big> primeNumbers;",
			"vector<big> spf(lim + 1, 1);",
			"",
			"void precomputeSieve(){",
			"\tsieve[0] = false;",
			"\tsieve[1] = false;",
			"\tbig sn = sqrt(lim);",
			"",
			"\t// initialising spf - O(n)",
			"\tfor (big i = 1; i <= lim; ++i){",
			"\t\tspf[i] = i;",
			"\t}",
			"",
			"\t// primary sieve and calculating Smallest Prime Factor - O(nloglogn)",
			"\tfor (big i = 2; i <= sn; ++i){",
			"\t\tif (sieve[i]){",
			"\t\t\tfor (big j = i * i; j <= lim; j += i){",
			"\t\t\t\tif (spf[j] == j){",
			"\t\t\t\t\tspf[j] = i;",
			"\t\t\t\t}",
			"\t\t\t\tsieve[j] = false;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"\t// storing prime numbers - O(N)",
			"\tbig ctr = 0;",
			"\tfor (big i = 0; i < lim; ++i){",
			"\t\tif (sieve[i]){",
			"\t\t\t++ctr;",
			"\t\t\tprimeNumbers.push_back(i);",
			"\t\t}",
			"\t\tsieveCount[i] = ctr;",
			"\t}",
			"}"
		],
		"description": "sieve of eratosthenes"
	},
	"z_function": {
		"prefix": "zfunction",
		"body": [
			"vector<big> z_function(string &s){",
			"\tbig n = s.size();",
			"\t// z[i] = length of largest substring starting at i which also is a prefix of s",
			"\tvector<big> z(n, 0);",
			"",
			"\tbig l = 0, r = 0;",
			"\tfor(big i = 1; i < n; ++i){",
			"\t\tif(i <= r){",
			"\t\t\tz[i] = min(z[i - l], r - i + 1);",
			"\t\t}",
			"",
			"\t\twhile(i + z[i] < n && s[i + z[i]] == s[z[i]]){",
			"\t\t\t++z[i];",
			"\t\t}",
			"",
			"\t\tif(i + z[i] - 1 > r){",
			"\t\t\tl = i;",
			"\t\t\tr = i + z[i] - 1;",
			"\t\t}",
			"\t}",
			"",
			"\treturn z;",
			"}"
		],
		"description": "z function"
	},
	"rabin_karp": {
		"prefix": "rabin_karp",
		"body": [
			"int m, p; ",
			"",
			"int mult(int a, int b){",
			"\treturn (a * 1ll * b) % m;",
			"}",
			"",
			"int add(int a, int b){",
			"\tint s = a + b;",
			"\tif(s > m){",
			"\t\ts -= m;",
			"\t}",
			"\treturn s;",
			"}",
			"",
			"int sub(int a, int b){",
			"\tint d = a - b; ",
			"\tif(d < 0){",
			"\t\td += m;",
			"\t}",
			"\treturn d;",
			"}",
			"",
			"int power(int a, int b){",
			"\tint x = 1;",
			"\twhile(b > 0){",
			"\t   if(b % 2 == 1){",
			"\t\t   x = (x * 1ll * a) % m;",
			"\t   } ",
			"\t   ",
			"\t   a = (a * 1ll * a) % m;",
			"\t   b /= 2;",
			"\t}",
			"\t",
			"\treturn x;",
			"}    ",
			"",
			"int divi(int a, int b){",
			"\treturn mult(a, power(b, m - 2));",
			"}",
			"",
			"void precompute_hash(string &str, vector<int> &hash){",
			"\tint n = str.size();",
			"\thash.assign(n, 0);",
			"\t",
			"\tfor(int i = 0; i < n; i++){",
			"\t\thash[i] = mult(power(p, i), str[i] - 'a' + 1);",
			"\t\tif(i != 0)",
			"\t\t\thash[i] = add(hash[i - 1], hash[i]);",
			"\t}",
			"}",
			"",
			"int give_hash(int l, int r, vector<int> &hash){",
			"\tif(l == 0){",
			"\t\treturn hash[r];",
			"\t} else{",
			"\t\treturn divi(sub(hash[r], hash[l - 1]), power(p, l));",
			"\t}",
			"}",
			"",
			"int give_hash(string &str){",
			"\tint n = str.size();",
			"\tint x = 0;",
			"\t",
			"\tfor(int i = 0; i < n; i++){",
			"\t\tx = add(x, mult(power(p, i), str[i] - 'a' + 1));",
			"\t}",
			"\t",
			"\treturn x;",
			"}",
			"",
			"int rabin_karp(string haystack, string needle) {",
			"\tm = 1e9 + 7;",
			"\tp = 33;",
			"\t",
			"\tint nl = needle.size();",
			"\tint nh = haystack.size();",
			"\t",
			"\tif(nl == 0) return 0;",
			"\t",
			"\tvector<int> hash;",
			"\t",
			"\tint needle_hash = give_hash(needle);",
			"\tprecompute_hash(haystack, hash);",
			"\t",
			"\tfor(int i = 0; i < nh - nl + 1; i++){",
			"\t\tif(needle_hash == give_hash(i, i + nl - 1, hash)){",
			"\t\t\treturn i;",
			"\t\t}",
			"\t}",
			"\t",
			"\treturn -1;",
			"}"
		],
		"description": "rabin karp algorithm for string matching"
	},
	"lazy_segment_tree": {
		"prefix": "lazysegmenttree",
		"body": [
			"struct segtree{",
			"\tbig n;",
			"\tvector<big> seg_t, lazy_t;",
			"",
			"\tsegtree(vector<big> &v){",
			"\t\tn = v.size();",
			"\t\tseg_t = vector<big>(4 * n);",
			"\t\tlazy_t = vector<big>(4 * n, 0);",
			"\t\tbuild(v, 1, 0, n - 1);",
			"\t}",
			"",
			"\tbig combine(big a, big b){",
			"\t\treturn a + b;",
			"\t}",
			"",
			"\tvoid build(vector<big> &arr, big node, big tl, big tr){",
			"\t\tif (tl == tr){",
			"\t\t\tseg_t[node] = arr[tl];",
			"\t\t}",
			"\t\telse{",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tbuild(arr, 2 * node, tl, tm);",
			"\t\t\tbuild(arr, 2 * node + 1, tm + 1, tr);",
			"",
			"\t\t\tseg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid push(big node){",
			"\t\tbig x = lazy_t[node];",
			"",
			"\t\tseg_t[2 * node] += x;",
			"\t\tseg_t[2 * node + 1] += x;",
			"",
			"\t\tlazy_t[2 * node] += x;",
			"\t\tlazy_t[2 * node + 1] += x;",
			"",
			"\t\tlazy_t[node] = 0;",
			"\t}",
			"",
			"\tvoid update(big node, big tl, big tr, big l, big r, big new_val){",
			"\t\tif(l > r){",
			"\t\t\treturn;",
			"\t\t}else if(l == tl && tr == r){",
			"\t\t\tseg_t[node] += new_val;",
			"\t\t\tlazy_t[node] += new_val;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tif(lazy_t[node] != 0){",
			"\t\t\t\tpush(node);",
			"\t\t\t}",
			"",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tupdate(2 * node, tl, tm, l, min(r, tm), new_val);",
			"\t\t\tupdate(2 * node + 1, tm + 1, tr, max(l, tm + 1), r, new_val);",
			"",
			"\t\t\tseg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid update(big l, big r, big new_val){",
			"\t\tupdate(1, 0, n - 1, l, r, new_val);",
			"\t}",
			"",
			"\tbig query(big node, big tl, big tr, big l, big r){",
			"\t\tif (l > r){",
			"\t\t\treturn;",
			"\t\t}else if(l == tl && r == tr){",
			"\t\t\treturn seg_t[node];",
			"\t\t}else{",
			"\t\t\tif(lazy_t[node] != 0){",
			"\t\t\t\tpush(node);",
			"\t\t\t}",
			"",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tbig q1 = query(2 * node, tl, tm, l, min(r, tm));",
			"\t\t\tbig q2 = query(2 * node + 1, tm + 1, tr, max(l, tm + 1), r);",
			"",
			"\t\t\treturn combine(q1, q2);",
			"\t\t}",
			"\t}",
			"",
			"\tbig query(big l, big r){",
			"\t\treturn query(1, 0, n - 1, l, r);",
			"\t}",
			"};"
		],
		"description": "segment tree with lazy propagation"
	},
	"euler_tour_traversal": {
		"prefix": "eulertourtraversal",
		"body": [
			"struct ETT{",
			"\tbig t, n, r;",
			"\tvector<big> st, end, ett;",
			"",
			"\tETT(big r1, vector<big> &val, G &gr){",
			"\t\tt = 0;",
			"\t\tr = r1;",
			"\t\tn = val.size();",
			"",
			"\t\tst.resize(n);",
			"\t\tend.resize(n);",
			"\t\tett.reserve(2 * n);",
			"\t\t",
			"\t\tbuild(r, -1, val, gr);",
			"\t}",
			"",
			"\tvoid build(big node, big par, vector<big> &val, G &gr){",
			"\t\tst[node] = t++;",
			"\t\tett.push_back(val[node]);",
			"",
			"\t\tfor(auto nebr : gr.g[node]){",
			"\t\t\tif(nebr != par){",
			"\t\t\t\tbuild(nebr, node, val, gr);",
			"\t\t\t}",
			"\t\t}",
			"",
			"\t\tend[node] = t++;",
			"\t\tett.push_back(val[node]);",
			"\t}",
			"};"
		],
		"description": "euler tour traversal of a tree"
	},
	"disjoint_set_union_depth": {
		"prefix": "dsudepth",
		"body": [
			"struct DSU{",
			"\tvector<big> par, depth;    ",
			"\tbig num_comps;",
			"",
			"\tDSU(big n){",
			"\t\tdepth.assign(n, 1);",
			"\t\tpar.resize(n);",
			"\t\tiota(all(depth), 0);",
			"\t\tnum_comps = n;",
			"\t}",
			"",
			"\tvoid union_(big a, big b){",
			"\t\ta = find(a);",
			"\t\tb = find(b);",
			"",
			"\t\tif (a != b){",
			"\t\t\tnum_comps--;",
			"",
			"\t\t\tif (depth[a] < depth[b]) swap(a, b);",
			"\t\t\tpar[b] = a;",
			"\t\t\tif(depth[a] == depth[b]) ++depth[a];",
			"\t\t}",
			"\t}   ",
			"",
			"\tbig find(big node){",
			"\t\tif(par[node] != node) par[node] = find(par[node]);",
			"\t\treturn par[node];",
			"\t}",
			"};"
		],
		"description": "disjoint set union with depth"
	},
	"input_output_suite": {
		"prefix": "iosuite",
		"body": [
			"void fastinput(big &number){",
			"\tbool negative = false;",
			"\tint c;",
			"",
			"\tnumber = 0;",
			"",
			"\tc = getchar();",
			"\tif (c == '-'){",
			"\t\tnegative = true;",
			"\t\tc = getchar();",
			"\t}",
			"",
			"\tfor (; (c > 47 && c < 58); c = getchar())",
			"\t\tnumber = number * 10 + c - 48;",
			"",
			"\tif (negative)",
			"\t\tnumber *= -1;",
			"}",
			"",
			"void io_on(){",
			"#ifndef ONLINE_JUDGE",
			"\tfreopen(\"../input.txt\", \"r\", stdin);",
			"\tfreopen(\"../output.txt\", \"w\", stdout);",
			"#endif",
			"}"
		],
		"description": "fast io and file io"
	},
	"disjoint_set_union_size": {
		"prefix": "dsusize",
		"body": [
			"struct DSU{",
			"\tvector<big> par, size;    ",
			"\tbig num_comps;",
			"",
			"\tDSU(big n){",
			"\t\tsize.assign(n, 1);",
			"\t\tpar.resize(n);",
			"\t\tiota(all(par), 0);",
			"\t\tnum_comps = n;",
			"\t}",
			"",
			"\tvoid union_(big a, big b){",
			"\t\ta = find(a);",
			"\t\tb = find(b);",
			"",
			"\t\tif (a != b){",
			"\t\t\tnum_comps--;",
			"",
			"\t\t\tif (size[a] < size[b]) swap(a, b);",
			"\t\t\tpar[b] = a;",
			"\t\t\tsize[a] += size[b];",
			"\t\t}",
			"\t}   ",
			"",
			"\tbig find(big node){",
			"\t\tif(par[node] != node) par[node] = find(par[node]);",
			"\t\treturn par[node];",
			"\t}",
			"};"
		],
		"description": "disjoint set union with size"
	},
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"void dijkstra(big src, big n, vector<big>& dist, vector<big>& par, vector<vector<pair<big, big>>>& g){",
			"\tdist.assign(n, INF);",
			"\tpar.assign(n, -1);",
			"\tdist[src] = 0;",
			"",
			"\tpriority_queue<pair<big, big>, vector<pair<big, big>>, greater<pair<big, big>>> pq;",
			"\tpq.push({ 0, src });",
			"",
			"\twhile (!pq.empty()) {",
			"\t\tpair<big, big> node = pq.top();",
			"\t\tpq.pop();",
			"",
			"\t\tbig dv = node.first;",
			"\t\tbig v = node.second;",
			"",
			"\t\tif (dv != dist[v]) {",
			"\t\t\tcontinue;",
			"\t\t}",
			"",
			"\t\tfor (auto nebr : g[v]) {",
			"\t\t\tbig to = nebr.first;",
			"\t\t\tbig wt = nebr.second;",
			"",
			"\t\t\tbig nd = dist[v] + wt;",
			"\t\t\tif (nd < dist[to]) {",
			"\t\t\t\tdist[to] = nd;",
			"\t\t\t\tpar[to] = v;",
			"\t\t\t\tpq.push({ nd, to });",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "dijkstra's algorithm for single source shortest path [O(n*log(n) + m*log(n)) = O(m*log(n))]"
	},
	"2_sat": {
		"prefix": "twosat",
		"body": [
			"void dfstopo(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &topo){",
			"\tvis[node] = 1;",
			" ",
			"\tfor(auto &nebr : g[node]){",
			"\t\tif(!vis[nebr]){",
			"\t\t\tdfstopo(nebr, g, vis, topo);",
			"\t\t}",
			"\t}",
			"\ttopo.push_back(node);",
			"}",
			" ",
			"void dfscomp(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &comp){",
			"\tvis[node] = 1;",
			"\tcomp.push_back(node);",
			" ",
			"\tfor(auto &nebr : g[node]){",
			"\t\tif(!vis[nebr]){",
			"\t\t\tdfscomp(nebr, g, vis, comp);",
			"\t\t}",
			"\t}",
			"}",
			" ",
			"bool twosat(vector<vector<big>> &g, vector<vector<big>> &ig, vector<big> &root, vector<big> &ans){",
			"\tbig n = root.size(), j = 0;",
			"\tvector<big> vis(n), topo, comp;",
			" ",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tif(!vis[i]){",
			"\t\t\tdfstopo(i, g, vis, topo); ",
			"\t\t}",
			"\t}",
			" ",
			"\treverse(all(topo));",
			"\tvis.assign(n, 0);",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tif(!vis[topo[i]]){",
			"\t\t\tcomp.clear(); ",
			" ",
			"\t\t\tdfscomp(topo[i], ig, vis, comp);",
			" ",
			"\t\t\tfor(auto &c : comp){",
			"\t\t\t\troot[c] = j;",
			"\t\t\t}",
			"\t\t\t++j;",
			"\t\t}",
			"\t}",
			"",
			"\tfor(big i = 0; i < n; i += 2){",
			"\t\tif(root[i] == root[i + 1]){",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\tans[i / 2] = root[i] > root[i + 1];",
			"\t}",
			"\treturn true;",
			"} "
		],
		"description": "boolean satisfiability problem"
	},
	"chinese_remainder_theorem": {
		"prefix": "chinesereamindertheorem",
		"body": [
			"big mult(big a, big b, big mod){",
			"\tbig ans = 0;",
			"\twhile (b){",
			"\t\tif (b & 1){",
			"\t\t\tans += a;",
			"\t\t\tans %= mod;",
			"\t\t}",
			"\t\ta += a;",
			"\t\ta %= mod;",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"big power(big a, big b, big mod){",
			"\tbig ans = 1;",
			"\twhile (b){",
			"\t\tif (b & 1){",
			"\t\t\tans = mult(ans, a, mod);",
			"\t\t}",
			"\t\ta = mult(a, a, mod);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"big modinv(big a, big mod){",
			"\treturn power(a, mod - 2, mod);",
			"}",
			"",
			"big crt(vector<big> &p, vector<big> &k){",
			"\tbig ans = 0; ",
			"\tbig n = p.size();",
			"",
			"\tbig prod = 1;",
			"\tfor (auto x : p){",
			"\t\tprod *= x;",
			"\t}",
			"",
			"\tfor (big i = 0; i < n; ++i){",
			"\t\tbig t = 1;",
			"\t\tfor (big j = 0; j < i; ++j){",
			"\t\t\tt *= p[j];",
			"\t\t\tt *= modinv(p[j], p[i]);",
			"\t\t\tt %= prod;",
			"\t\t}",
			"\t\tans += mult(t, k[i] - ans + prod, prod);",
			"\t\tans %= prod;",
			"\t}",
			"",
			"\treturn ans;",
			"}"
		],
		"description": "chinese remainder theorem"
	},
	"longest_increasing_subsequence": {
		"prefix": "lis ",
		"body": [
			"void lis(vector<big> &v, vector<big> &dp){",
			"\tbig n = v.size();",
			"",
			"\t// dp[i] = last element in increasing subsequence of length i - 1",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tauto it = upper_bound(all(dp), v[i]); ",
			"\t\tif(it == dp.end()){",
			"\t\t\tdp.push_back(v[i]);",
			"\t\t}else{",
			"\t\t\t*it = v[i];",
			"\t\t}",
			"\t}",
			"}"
		],
		"description": "longest increasing subsequence"
	},
	"segment_tree": {
		"prefix": "segmenttree",
		"body": [
			"struct segtree{",
			"\tbig n;",
			"\tvector<big> seg_t;",
			"",
			"\tsegtree(vector<big> &v){",
			"\t\tn = v.size();",
			"\t\tseg_t = vector<big>(4 * n);",
			"\t\tbuild(v, 1, 0, n - 1);",
			"\t}",
			"",
			"\tbig combine(big a, big b){",
			"\t\treturn a + b;",
			"\t}",
			"",
			"\tvoid build(vector<big> &arr, big node, big tl, big tr){",
			"\t\tif (tl == tr){",
			"\t\t\tseg_t[node] = arr[tl];",
			"\t\t}",
			"\t\telse{",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tbuild(arr, 2 * node, tl, tm);",
			"\t\t\tbuild(arr, 2 * node + 1, tm + 1, tr);",
			"",
			"\t\t\tseg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid update(big node, big tl, big tr, big pos, big new_val){",
			"\t\tif(!(tl <= pos && pos <= tr)){",
			"\t\t\treturn; ",
			"\t\t}",
			"",
			"\t\tif(tl == tr){",
			"\t\t\tseg_t[node] = new_val;",
			"\t\t}else{",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tupdate(2 * node, tl, tm, pos, new_val);",
			"\t\t\tupdate(2 * node + 1, tm + 1, tr, pos, new_val);",
			"",
			"\t\t\tseg_t[node] = combine(seg_t[2 * node], seg_t[2 * node + 1]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid update(big pos, big r, big new_val){",
			"\t\tupdate(1, 0, n - 1, pos, new_val);",
			"\t}",
			"",
			"\tbig query(big node, big tl, big tr, big l, big r){",
			"\t\tif (l > r){",
			"\t\t\treturn;",
			"\t\t}else if(l == tl && r == tr){",
			"\t\t\treturn seg_t[node];",
			"\t\t}else{",
			"\t\t\tbig tm = (tr - tl) / 2 + tl;",
			"",
			"\t\t\tbig q1 = query(2 * node, tl, tm, l, min(r, tm));",
			"\t\t\tbig q2 = query(2 * node + 1, tm + 1, tr, max(l, tm + 1), r);",
			"",
			"\t\t\treturn combine(q1, q2);",
			"\t\t}",
			"\t}",
			"",
			"\tbig query(big l, big r){",
			"\t\treturn query(1, 0, n - 1, l, r);",
			"\t}",
			"};"
		],
		"description": "segment tree"
	},
	"kosaraju": {
		"prefix": "kosaraju",
		"body": [
			"void dfstopo(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &topo){",
			"\tvis[node] = 1;",
			"",
			"\tfor(auto &nebr : g[node]){",
			"\t\tif(!vis[nebr]){",
			"\t\t\tdfstopo(nebr, g, vis, topo);",
			"\t\t}",
			"\t}",
			"\ttopo.push_back(node);",
			"}",
			"",
			"void dfscomp(big node, vector<vector<big>> &g, vector<big> &vis, vector<big> &comp){",
			"\tvis[node] = 1;",
			"\tcomp.push_back(node);",
			"",
			"\tfor(auto &nebr : g[node]){",
			"\t\tif(!vis[nebr]){",
			"\t\t\tdfscomp(nebr, g, vis, comp);",
			"\t\t}",
			"\t}",
			"}",
			"",
			"void kosaraju(vector<vector<big>> &g, vector<vector<big>> &ig, vector<big> &root, vector<big> &roots, vector<vector<big>> &cg){",
			"\tbig n = root.size(), r;",
			"\tvector<big> vis(n), topo, comp;",
			"",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tif(!vis[i]){",
			"\t\t\tdfstopo(i, g, vis, topo); ",
			"\t\t}",
			"\t}",
			"",
			"\treverse(all(topo));",
			"\tvis.assign(n, 0);",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tif(!vis[topo[i]]){",
			"\t\t\tcomp.clear(); ",
			"",
			"\t\t\tdfscomp(topo[i], ig, vis, comp);",
			"",
			"\t\t\tr = comp.back(); ",
			"\t\t\tfor(auto &c : comp){",
			"\t\t\t\troot[c] = r;",
			"\t\t\t}",
			"\t\t\troots.push_back(r); ",
			"\t\t}",
			"\t}",
			"\t",
			"\tfor(big i = 0; i < n; ++i){",
			"\t\tfor(auto &nebr : g[i]){",
			"\t\t\tif(root[i] != root[nebr]){",
			"\t\t\t\tcg[root[i]].push_back(root[nebr]); ",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"} "
		],
		"description": "kosaraju's algorithm for strongly connected components"
	}
}
